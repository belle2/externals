--- include/Pythia8Plugins/EvtGen.h
+++ include/Pythia8Plugins/EvtGen.h
@@ -14,6 +14,7 @@
 #include "EvtGenBase/EvtParticle.hh"
 #include "EvtGenBase/EvtParticleFactory.hh"
 #include "EvtGenBase/EvtPDL.hh"
+#include "EvtGenBase/EvtDecayTable.hh"
 #include "EvtGenBase/EvtRandomEngine.hh"
 #include "EvtGenBase/EvtDecayBase.hh"
 #include "EvtGenExternal/EvtExternalGenList.hh"
@@ -52,22 +53,48 @@
 // considerable complication. Consequently, EvtGen is called on the
 // complete event record after all steps of Pythia are completed.
 
+// Oftentimes a specific "signal" decay is needed to occur once in an
+// event, and all other decays performed normally. This is possible
+// via reading in a user decay file (with readDecayFile) and creating
+// aliased particles with names ending with signalSuffix. By default,
+// this is "_SIGNAL". When decay() is called, all particles in the
+// Pythia event record that are of the same types as the signal
+// particles are collected. One is selected at random and decayed via
+// the channel(s) defined for the aliased signal particle. All other
+// particles are decayed normally.
+
+// It is also possible to specify a status needed to consider a
+// particle as "signal". This can be done by modifying the signals
+// map, e.g. if the tau- is a signal particle, then
+//     signals[15].status = 201
+// will only only select as signal any tau- with this status. This
+// allows the event record to be changed before decays, so only
+// certain particles are selected as possible signal candidates
+// (e.g. passing kinematic requirements).
+
 class EvtGenDecays {
 
 public:
 
   // Constructor.
   EvtGenDecays(Pythia *pythiaPtrIn, string decayFile, string particleDataFile,
-    EvtExternalGenList *extPtr = 0, EvtAbsRadCorr *fsrPtr = 0,
-    int mixing = 1, bool xml = false, bool limit = true);
+    EvtExternalGenList *extPtrIn = 0, EvtAbsRadCorr *fsrPtrIn = 0,
+    int mixing = 1, bool xml = false, bool limit = true,
+    bool extUse = true, bool fsrUse = true);
 
   // Destructor.
   ~EvtGenDecays() {
-    if (evtgen) delete evtgen; if (owner && genlist) delete genlist;}
+    if (evtgen) delete evtgen;
+    if (extOwner && extPtr) delete extPtr; 
+    if (fsrOwner && fsrPtr) delete fsrPtr;
+  }
 
   // Perform all decays.
   void decay();
 
+  // Decay a single particle.
+  void decay(Particle *pyPro, EvtId *egId = 0);
+
   // Stop EvtGen decaying a particle and use Pythia unless "pythia = false".
   void exclude(int id, bool pythia = true) {
     if (!pythiaPtr) return; set<int>::iterator itr = ids.find(id);
@@ -82,15 +109,26 @@
 
   // Read an EvtGen user decay file.
   void readDecayFile(string decayFile, bool xml = false) {
-    evtgen->readUDecay(decayFile.c_str(), xml);}
+    evtgen->readUDecay(decayFile.c_str(), xml); updateDecays();}
 
   // List of additional models.
-  bool owner;
-  EvtExternalGenList *genlist;
+  bool extOwner, fsrOwner;
+  EvtExternalGenList *extPtr;
+  EvtAbsRadCorr      *fsrPtr;
   list<EvtDecayBase*> models;
 
+  // Map of signal particle ID to status code and EvtGen ID.
+  struct signal {int status; EvtId egId;};
+  map<int, signal> signals;
+
+  // The suffix indicating an EvtGen particle or alias is signal.
+  string signalSuffix;
+  
 protected:
 
+  // Update the particles to decay and the signals from EvtGen.
+  void updateDecays();
+
   // The pointer to the associated Pythia object.
   Pythia *pythiaPtr;
 
@@ -127,47 +165,54 @@
 // decaying a particle with EvtGen.
 
 // The constructor is designed to have the exact same form as the
-// EvtGen constructor except for three differences.
+// EvtGen constructor except for these five differences.
 // (1) The first variable is the pointer to the Pythia object.
-// (2) The last variable is a flag to limit decays based on the Pythia
+// (2) The third last argument is a flag to limit decays based on the Pythia
 //     criteria.
-// (3) No random engine pointer is passed, as this is obtained from
+// (3) The second last argument is a flag if external models should be passed
+//     to EvtGen (default is true).
+// (4) The last argument is a flag if an FSR model should be passed
+//     to EvtGen (default is true).
+// (5) No random engine pointer is passed, as this is obtained from
 //     Pythia.
 
 //   pythiaPtrIn:      the pointer to the associated Pythia object.
 //   decayFile:        the name of the decay file to pass to EvtGen.
 //   particleDataFile: the name of the particle data file to pass to EvtGen.
-//   extPtr:           the optional EvtExternalGenList pointer, this must be
-//                     be provided if fsrPtr is provided to avoid double
+//   extPtrIn:         the optional EvtExternalGenList pointer, this must be
+//                     be provided if fsrPtrIn is provided to avoid double
 //                     initializations.
-//   fsrPtr:           the EvtAbsRadCorr pointer to pass to EvtGen.
+//   fsrPtrIn:         the EvtAbsRadCorr pointer to pass to EvtGen.
 //   mixing:           the mixing type to pass to EvtGen.
 //   xml:              flag to use XML files to pass to EvtGen.
 //   limit:            flag to limit particle decays based on Pythia criteria.
+//   extUse:           flag to use external models with EvtGen.
+//   fsrUse:           flag to use radiative correction engine with EvtGen.
 
 EvtGenDecays::EvtGenDecays(Pythia *pythiaPtrIn, string decayFile,
-  string particleDataFile, EvtExternalGenList *extPtr,
-  EvtAbsRadCorr *fsrPtr, int mixing, bool xml, bool limit) :
+  string particleDataFile, EvtExternalGenList *extPtrIn,
+  EvtAbsRadCorr *fsrPtrIn, int mixing, bool xml, bool limit, 
+  bool extUse, bool fsrUse) :
+  extPtr(extPtrIn), fsrPtr(fsrPtrIn), signalSuffix("_SIGNAL"),
   pythiaPtr(pythiaPtrIn), rndm(&pythiaPtr->rndm) {
 
   // Initialize EvtGen.
-  if (fsrPtr && !extPtr) {
-    if (pythiaPtr) pythiaPtr->info.errorMsg("Error in EvtGenDecays: fsrPtr "
-      "provided but extPtr is null.");
+  if (!extPtr && fsrPtr) {
+    if (pythiaPtr) pythiaPtr->info.errorMsg("Error in EvtGenDecays: extPtr "
+      "is null but fsrPtr is provided.");
     return;
-  } else if (extPtr) {genlist = extPtr; owner = false;}
-  else {genlist = new EvtExternalGenList(); owner = true;}
-  models = genlist->getListOfModels();
+  }
+  if (extPtr) extOwner = false;
+  else {extOwner = true; extPtr = new EvtExternalGenList();}
+  if (fsrPtr) fsrOwner = false;
+  else {fsrOwner = true; fsrPtr = extPtr->getPhotosModel();}
+  models = extPtr->getListOfModels();
   evtgen = new EvtGen(decayFile.c_str(), particleDataFile.c_str(),
-    &rndm, fsrPtr, &models, mixing, xml);
+    &rndm, fsrUse ? fsrPtr : 0, extUse ? &models : 0, mixing, xml);
 
   // Set Pythia particles as stable.
   if (!pythiaPtr) return;
-  for (int iPrt = 0; iPrt < (int)EvtPDL::entries(); ++iPrt) {
-    int id = EvtPDL::getStdHep(EvtPDL::getEntry(iPrt));
-    ids.insert(id);
-    pythiaPtr->particleData.mayDecay(id, false);
-  }
+  updateDecays();
   limitTau0     = pythiaPtr->settings.flag("ParticleDecays:limitTau0");
   tau0Max       = pythiaPtr->settings.parm("ParticleDecays:tau0Max");
   limitTau      = pythiaPtr->settings.flag("ParticleDecays:limitTau");
@@ -184,19 +229,23 @@
 
 //--------------------------------------------------------------------------
 
-// The decay routine.
+// Perform all decays.
 
 // All particles in the event record that can be decayed by EvtGen are
-// decayed. The production vertex of each particle (which can also be
-// obtained in EvtGen via EvtParticle::get4Pos()) is set by the decay
-// vertex of its mother, which in turn is calculated from the mother's
-// lifetime. The status code 93 is used to indicate an external decay.
+// decayed. If a particle is a signal particle, then this is stored in
+// a vector of signal particles. A signal particle is only stored if
+// its status is the same as the status provided in the signals map. A
+// negative status in the signal map indicates that all statuses
+// should be accepted. After all signal particles are identified, one
+// is randomly chosen and decayed as signal. The remainder are decayed
+// normally.
 
 void EvtGenDecays::decay() {
 
   // Loop over all particles in the Pythia event.
   if (!pythiaPtr || !evtgen) return;
   Event &event = pythiaPtr->event;
+  vector<Particle*> pySigs;
   for (int iPro = 0; iPro < event.size(); ++iPro) {
 
     // Check particle is final and can be decayed by EvtGen.
@@ -204,54 +253,100 @@
     if (!pyPro->isFinal()) continue;
     if (ids.find(pyPro->idAbs()) == ids.end()) continue;
 
-    // Perform the decay of the progenitor.
-    EvtParticle *egPro = EvtParticleFactory::particleFactory
-      (EvtPDL::evtIdFromStdHep(pyPro->id()),
+    // Store if valid signal, otherwise perform the decay of the progenitor.
+    map<int, signal>::iterator pySig = signals.find(pyPro->id());
+    if (pySig != signals.end() && 
+	(pySig->second.status < 0 || pySig->second.status == pyPro->status()))
+      pySigs.push_back(pyPro);
+    else decay(pyPro);
+  }
+  if (pySigs.size() == 0) return;
+
+  // Select signal particle to decay as signal.
+  double work = pythiaPtr->rndm.flat() * pySigs.size();
+  int index = -1;
+  do {work -= 1; ++index;} while (work > 0 && index < int(pySigs.size()));
+
+  // Decay the signal particles.
+  for (int iSig = 0; iSig < (int)pySigs.size(); ++iSig) {
+    if (iSig == index) decay(pySigs[iSig], &signals[pySigs[iSig]->id()].egId);
+    else decay(pySigs[iSig]);
+  }
+
+}
+
+//--------------------------------------------------------------------------
+
+// Decay a single particle.
+
+// If no EvtGen ID is provided via egId, then the default ID from the
+// PDG ID is used. The production vertex of each particle (which can
+// also be obtained in EvtGen via EvtParticle::get4Pos()) is set by
+// the decay vertex of its mother, which in turn is calculated from
+// the mother's lifetime. The status code 93 is used to indicate an
+// external decay.
+
+void EvtGenDecays::decay(Particle *pyPro, EvtId *egId) {
+
+  // Perform the decay of the progenitor.
+  if (!pythiaPtr || !evtgen) return;
+  Event &event = pythiaPtr->event;
+  EvtParticle *egPro;
+  if (!egId)
+    egPro = EvtParticleFactory::particleFactory
+      (EvtPDL::evtIdFromStdHep(pyPro->id()), 
        EvtVector4R(pyPro->e(), pyPro->px(), pyPro->py(), pyPro->pz()));
-    egPro->setDiagonalSpinDensity();
-    evtgen->generateDecay(egPro);
-    if (egPro->getNDaug() == 0) {egPro->deleteTree(); continue;}
-    pyPro->tau(egPro->getLifetime());
-
-    // Add the decay tree to the event record.
-    vector< pair<EvtParticle*, int> >
-      moms(1, pair<EvtParticle*, int>(egPro, iPro));
-    while (moms.size() != 0) {
-
-      // Check if particle should decay.
-      EvtParticle* egMom = moms.back().first;
-      int          iMom  = moms.back().second;
-      Particle*    pyMom = &event[iMom];
-      moms.pop_back();
-      if (limitDecay) {
-        if (limitTau0 && pyMom->tau0() > tau0Max)    continue;
-        else if (limitTau && pyMom->tau() > tauMax)  continue;
-        else if (limitRadius && pow2(pyMom->xDec())
-                 + pow2(pyMom->zDec()) > pow2(rMax)) continue;
-        else if (limitCylinder && (pow2(pyMom->xDec()) + pow2(pyMom->yDec())
-                                   > pow2(xyMax) || abs(pyMom->zDec()) > zMax))
-          continue;
-      }
-
-      // Set the children of the mother.
-      pyMom->daughters(event.size(), event.size() + egMom->getNDaug() - 1);
-      pyMom->statusNeg();
-      Vec4 vProd = pyMom->vDec();
-      for (int iDtr = 0 ; iDtr < (int)egMom->getNDaug(); ++iDtr) {
-        EvtParticle *egDtr = egMom->getDaug(iDtr);
-        int          id    = egDtr->getPDGId();
-        EvtVector4R  p     = egDtr->getP4Lab();
-        int idx = event.append(id, 93, iMom, 0, 0, 0, 0, 0, p.get(1),
-                               p.get(2), p.get(3), p.get(0), egDtr->mass());
-        Particle *pyDtr = &event.back();
-        pyDtr->vProd(vProd);
-        pyDtr->tau(egDtr->getLifetime());
-        if(egDtr->getNDaug() > 0)
-          moms.push_back(pair<EvtParticle*, int>(egDtr, idx));
-      }
+  else 
+    egPro = EvtParticleFactory::particleFactory
+      (*egId, EvtVector4R(pyPro->e(), pyPro->px(), pyPro->py(), pyPro->pz()));
+  egPro->setDiagonalSpinDensity();
+  evtgen->generateDecay(egPro);
+  if (egPro->getNDaug() == 0) {egPro->deleteTree(); return;}
+  pyPro->tau(egPro->getLifetime());
+  
+  // Add the decay tree to the event record.
+  vector< pair<EvtParticle*, int> > 
+    moms(1, pair<EvtParticle*, int>(egPro, pyPro->index()));
+  while (moms.size() != 0) {
+
+    // Check if particle should decay.
+    EvtParticle* egMom = moms.back().first;
+    int          iMom  = moms.back().second;
+    Particle*    pyMom = &event[iMom];
+    moms.pop_back();
+    if (limitDecay) {
+      if (limitTau0 && pyMom->tau0() > tau0Max)    continue;
+      else if (limitTau && pyMom->tau() > tauMax)  continue;
+      else if (limitRadius && pow2(pyMom->xDec())
+	       + pow2(pyMom->zDec()) > pow2(rMax)) continue;
+      else if (limitCylinder && (pow2(pyMom->xDec()) + pow2(pyMom->yDec())
+				 > pow2(xyMax) || abs(pyMom->zDec()) > zMax))
+	continue;
+    }
+
+    // Set the children of the mother.
+    pyMom->daughters(event.size(), event.size() + egMom->getNDaug() - 1);
+    pyMom->statusNeg();
+    Vec4 vProd = pyMom->vDec();
+    for (int iDtr = 0 ; iDtr < (int)egMom->getNDaug(); ++iDtr) {
+      EvtParticle *egDtr = egMom->getDaug(iDtr);
+      int          id    = egDtr->getPDGId();
+      EvtVector4R  p     = egDtr->getP4Lab();
+
+      int statuscode = 93;
+      if(id==22 && egDtr->getAttribute("FSR")) statuscode = 94; //modification Belle II
+
+      int idx = event.append(id, statuscode, iMom, 0, 0, 0, 0, 0, p.get(1),
+			     p.get(2), p.get(3), p.get(0), egDtr->mass());
+      Particle *pyDtr = &event.back();
+      pyDtr->vProd(vProd);
+      pyDtr->tau(egDtr->getLifetime());
+      if(egDtr->getNDaug() > 0)
+	moms.push_back(pair<EvtParticle*, int>(egDtr, idx));
     }
-    egPro->deleteTree();
   }
+  egPro->deleteTree();
+
 }
 
 //--------------------------------------------------------------------------
@@ -265,15 +360,15 @@
 void EvtGenDecays::updatePythia() {
   if (!pythiaPtr || !evtgen) return;
   for (int entry = 0; entry < (int)EvtPDL::entries(); ++entry) {
-    EvtId egid = EvtPDL::getEntry(entry);
-    int   pyid = EvtPDL::getStdHep(egid);
-    pythiaPtr->particleData.spinType  (pyid, EvtPDL::getSpinType(egid));
-    pythiaPtr->particleData.chargeType(pyid, EvtPDL::chg3(egid));
-    pythiaPtr->particleData.m0        (pyid, EvtPDL::getMass(egid));
-    pythiaPtr->particleData.mWidth    (pyid, EvtPDL::getWidth(egid));
-    pythiaPtr->particleData.mMin      (pyid, EvtPDL::getMinMass(egid));
-    pythiaPtr->particleData.mMax      (pyid, EvtPDL::getMaxMass(egid));
-    pythiaPtr->particleData.tau0      (pyid, EvtPDL::getctau(egid));
+    EvtId egId = EvtPDL::getEntry(entry);
+    int   pyId = EvtPDL::getStdHep(egId);
+    pythiaPtr->particleData.spinType  (pyId, EvtPDL::getSpinType(egId));
+    pythiaPtr->particleData.chargeType(pyId, EvtPDL::chg3(egId));
+    pythiaPtr->particleData.m0        (pyId, EvtPDL::getMass(egId));
+    pythiaPtr->particleData.mWidth    (pyId, EvtPDL::getWidth(egId));
+    pythiaPtr->particleData.mMin      (pyId, EvtPDL::getMinMass(egId));
+    pythiaPtr->particleData.mMax      (pyId, EvtPDL::getMaxMass(egId));
+    pythiaPtr->particleData.tau0      (pyId, EvtPDL::getctau(egId));
   }
 }
 
@@ -288,14 +383,45 @@
 
 void EvtGenDecays::updateEvtGen() {
   if (!pythiaPtr || !evtgen) return;
-  int pyid = pythiaPtr->particleData.nextId(0);
-  while (pyid != 0) {
-    EvtId egid = EvtPDL::evtIdFromStdHep(pyid);
-    EvtPDL::reSetMass   (egid, pythiaPtr->particleData.m0(pyid));
-    EvtPDL::reSetWidth  (egid, pythiaPtr->particleData.mWidth(pyid));
-    EvtPDL::reSetMassMin(egid, pythiaPtr->particleData.mMin(pyid));
-    EvtPDL::reSetMassMax(egid, pythiaPtr->particleData.mMax(pyid));
-    pyid = pythiaPtr->particleData.nextId(pyid);
+  int pyId = pythiaPtr->particleData.nextId(0);
+  while (pyId != 0) {
+    EvtId egId = EvtPDL::evtIdFromStdHep(pyId);
+    EvtPDL::reSetMass   (egId, pythiaPtr->particleData.m0(pyId));
+    EvtPDL::reSetWidth  (egId, pythiaPtr->particleData.mWidth(pyId));
+    EvtPDL::reSetMassMin(egId, pythiaPtr->particleData.mMin(pyId));
+    EvtPDL::reSetMassMax(egId, pythiaPtr->particleData.mMax(pyId));
+    pyId = pythiaPtr->particleData.nextId(pyId);
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Update the particles to decay and the signals from EvtGen.
+
+// All particle entries in EvtGen are checked to see if they should be
+// set stable in Pythia. If an EvtGen particle has no decay modes,
+// then Pythia is still allowed to decay the particle.  Any particle
+// or alias that ends with signalSuffix is taken as a signal
+// particle.
+  
+void EvtGenDecays::updateDecays() {
+  if (!pythiaPtr) return;
+  for (int iEntry = 0; iEntry < (int)EvtPDL::entries(); ++iEntry) {
+    EvtId egId = EvtPDL::getEntry(iEntry);
+    int   pyId = EvtPDL::getStdHep(egId);
+    if (EvtDecayTable::getInstance()->getNModes(egId) == 0) continue;
+    ids.insert(pyId);
+    pythiaPtr->particleData.mayDecay(pyId, false);
+
+    // Check for signal.
+    string egName = EvtPDL::name(egId);
+    if (egName.size() <= signalSuffix.size() || egName.substr
+	(egName.size() - signalSuffix.size()) != signalSuffix) continue;
+    map<int, signal>::iterator sig = signals.find(pyId);
+    if (sig == signals.end()) {
+      signals[pyId].status = -1;
+      signals[pyId].egId   = egId;
+    } else sig->second.egId = egId;
   }
 }
 
