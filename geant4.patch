Index: source/processes/optical/src/G4OpBoundaryProcess.cc
===================================================================
--- source/processes/optical/src/G4OpBoundaryProcess.cc	2012-02-27 10:57:01.000000000 +0900
+++ source/processes/optical/src/G4OpBoundaryProcess.cc	2012-02-27 10:38:56.000000000 +0900
@@ -148,6 +148,7 @@
         theStatus = Undefined;
 
         aParticleChange.Initialize(aTrack);
+        aParticleChange.ProposeVelocity(aTrack.GetVelocity());
 
         G4StepPoint* pPreStepPoint  = aStep.GetPreStepPoint();
         G4StepPoint* pPostStepPoint = aStep.GetPostStepPoint();
@@ -480,7 +481,9 @@
 	aParticleChange.ProposePolarization(NewPolarization);
 
         if ( theStatus == FresnelRefraction ) {
-           G4double finalVelocity = aTrack.CalculateVelocityForOpticalPhoton();
+           G4MaterialPropertyVector* groupvel =
+           Material2->GetMaterialPropertiesTable()->GetProperty("GROUPVEL");
+           G4double finalVelocity = groupvel->Value(thePhotonMomentum);
            aParticleChange.ProposeVelocity(finalVelocity);
         }

Index: source/physics_lists/builders/src/G4EmStandardPhysics.cc
===================================================================
--- source/physics_lists/builders/src/G4EmStandardPhysics.cc 2012-03-10 18:06:59.792944000 +0900
+++ source/physics_lists/builders/src/G4EmStandardPhysics.cc 2012-03-10 18:05:00.941355000 +0900
@@ -190,7 +190,7 @@
                particleName == "mu-"    ) {
 
       G4MuMultipleScattering* msc = new G4MuMultipleScattering();
-      msc->AddEmModel(0, new G4WentzelVIModel());
+      //msc->AddEmModel(0, new G4WentzelVIModel());   commented out as recommended by Vladimir Ivantchenko
 
       G4MuBremsstrahlung* mub = new G4MuBremsstrahlung();
       G4MuPairProduction* mup = new G4MuPairProduction();
@@ -199,7 +199,7 @@
       ph->RegisterProcess(new G4MuIonisation(), particle);
       ph->RegisterProcess(mub, particle);
       ph->RegisterProcess(mup, particle);
-      ph->RegisterProcess(new G4CoulombScattering(), particle);
+      //ph->RegisterProcess(new G4CoulombScattering(), particle);   commented out as recommended by Vladimir Ivantchenko
 
     } else if (particleName == "alpha" ||
                particleName == "He3") {
 
Index: source/processes/electromagnetic/xrays/src/G4SynchrotronRadiation.cc
===================================================================
--- source/processes/electromagnetic/xrays/src/G4SynchrotronRadiation.cc	2011-12-02 16:09:04.000000000 +0100
+++ source/processes/electromagnetic/xrays/src/G4SynchrotronRadiation.cc	2012-03-24 14:17:42.414264831 +0100
@@ -63,8 +63,8 @@
   fFieldPropagator = transportMgr->GetPropagatorInField();
 
   fLambdaConst = std::sqrt(3.0)*electron_mass_c2/
-                           (2.5*fine_structure_const*eplus*c_light) ;
-  fEnergyConst = 1.5*c_light*c_light*eplus*hbar_Planck/electron_mass_c2  ;
+                           (2.5*fine_structure_const*eplus*c_light);
+  fEnergyConst = 1.5*c_light*c_light*eplus*hbar_Planck/electron_mass_c2 ;
 
   SetProcessSubType(fSynchrotronRadiation);
   verboseLevel=1;
@@ -96,7 +96,7 @@
 
   const G4DynamicParticle* aDynamicParticle = trackData.GetDynamicParticle();
 
-  *condition = NotForced ;
+  *condition = NotForced;
 
   G4double gamma = aDynamicParticle->GetTotalEnergy()/
                    aDynamicParticle->GetMass();
@@ -126,7 +126,7 @@
     }
     if ( fieldExertsForce )
     {
-      pField = fieldMgr->GetDetectorField() ;
+      pField = fieldMgr->GetDetectorField();
       G4ThreeVector  globPosition = trackData.GetPosition();
 
       G4double  globPosVec[4], FieldValueVec[6];
@@ -145,8 +145,8 @@
 
 
       G4ThreeVector unitMomentum = aDynamicParticle->GetMomentumDirection();
-      G4ThreeVector unitMcrossB  = FieldValue.cross(unitMomentum) ;
-      G4double perpB             = unitMcrossB.mag() ;
+      G4ThreeVector unitMcrossB  = FieldValue.cross(unitMomentum);
+      G4double perpB             = unitMcrossB.mag();
 
       if( perpB > 0.0 ) MeanFreePath = fLambdaConst/perpB;
       else              MeanFreePath = DBL_MAX;
@@ -206,7 +206,7 @@
   G4double particleCharge = aDynamicParticle->GetDefinition()->GetPDGCharge();
 
   G4ThreeVector  FieldValue;
-  const G4Field*   pField = 0 ;
+  const G4Field*   pField = 0;
 
   G4FieldManager* fieldMgr=0;
   G4bool          fieldExertsForce = false;
@@ -223,22 +223,22 @@
   }
   if ( fieldExertsForce )
   {
-    pField = fieldMgr->GetDetectorField() ;
-    G4ThreeVector  globPosition = trackData.GetPosition() ;
-    G4double  globPosVec[4], FieldValueVec[6] ;
-    globPosVec[0] = globPosition.x() ;
-    globPosVec[1] = globPosition.y() ;
-    globPosVec[2] = globPosition.z() ;
+    pField = fieldMgr->GetDetectorField();
+    G4ThreeVector  globPosition = trackData.GetPosition();
+    G4double  globPosVec[4], FieldValueVec[6];
+    globPosVec[0] = globPosition.x();
+    globPosVec[1] = globPosition.y();
+    globPosVec[2] = globPosition.z();
     globPosVec[3] = trackData.GetGlobalTime();
 
-    pField->GetFieldValue( globPosVec, FieldValueVec ) ;
+    pField->GetFieldValue( globPosVec, FieldValueVec );
     FieldValue = G4ThreeVector( FieldValueVec[0],
                                    FieldValueVec[1],
                                    FieldValueVec[2]   );
 
     G4ThreeVector unitMomentum = aDynamicParticle->GetMomentumDirection();
     G4ThreeVector unitMcrossB = FieldValue.cross(unitMomentum);
-    G4double perpB = unitMcrossB.mag() ;
+    G4double perpB = unitMcrossB.mag();
     if(perpB > 0.0)
     {
       // M-C of synchrotron photon energy
@@ -255,15 +255,33 @@
       G4ParticleMomentum
       particleDirection = aDynamicParticle->GetMomentumDirection();
 
-      // M-C of its direction
+      // M-C of its direction, simplified dipole boosted approach
 
-      G4double Teta = G4UniformRand()/gamma ;    // Very roughly
+      // G4double Teta, fteta;  // = G4UniformRand()/gamma;    // Very roughly
 
-      G4double Phi  = twopi * G4UniformRand() ;
+      G4double cosTheta, sinTheta, fcos, beta;
 
-      G4double dirx = std::sin(Teta)*std::cos(Phi) ,
-               diry = std::sin(Teta)*std::sin(Phi) ,
-               dirz = std::cos(Teta) ;
+  do
+  { 
+    cosTheta = 1. - 2.*G4UniformRand();
+    fcos     = (1 + cosTheta*cosTheta)*0.5;
+  }
+  while( fcos < G4UniformRand() );
+
+  beta = std::sqrt(1. - 1./(gamma*gamma));
+
+  cosTheta = (cosTheta + beta)/(1. + beta*cosTheta);
+
+  if( cosTheta >  1. ) cosTheta =  1.;
+  if( cosTheta < -1. ) cosTheta = -1.;
+
+  sinTheta = std::sqrt(1. - cosTheta*cosTheta );
+
+      G4double Phi  = twopi * G4UniformRand();
+
+      G4double dirx = sinTheta*std::cos(Phi) ,
+               diry = sinTheta*std::sin(Phi) ,
+               dirz = cosTheta;
 
       G4ThreeVector gammaDirection ( dirx, diry, dirz);
       gammaDirection.rotateUz(particleDirection);
@@ -295,7 +313,7 @@
 
       // Update the incident particle
 
-      G4double newKinEnergy = kineticEnergy - energyOfSR ;
+      G4double newKinEnergy = kineticEnergy - energyOfSR;
       aParticleChange.ProposeLocalEnergyDeposit (0.);
 
       if (newKinEnergy > 0.)
