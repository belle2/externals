diff --git a/Makefile b/Makefile
index b285128..ef4d0ae 100644
--- a/Makefile
+++ b/Makefile
@@ -2,32 +2,40 @@ include eemmg-lib/Makefile.inc
 CC=gcc
 F77=gfortran
 FC=gfortran
-test_SOURCES = virtualpions.f momenta_quad.f virt_pions/prog.f virt_pions/dotprod_QUAD.f virt_pions/tensor_redux_Bij_new_Re_Com_QUAD.f virt_pions/tensor_redux_Cij_new_Re_Com_G_QUAD.f virt_pions/tensor_redux_Dij_new_Re_Com_G_QUAD.f virt_pions/tensor_redux_Eij_new_Re_Com_G_QUAD_Pentabox.f virt_pions/QUADE0FunctionsG.f virt_pions/Pentabox_full_isrHelSum_temp.f virt_pions/cross_ISRHelSum_temp.f virt_pions/Pentabox_PIFSRHelSum_temp.f virt_pions/cross_FSRHelSum_temp.f  hard_soft_part/one_photon.f hard_soft_part/soft_integrals.f virt_pions/test_vFSR.f virt_pions/dotprod.f virt_pions/tensor_redux_Bij_new_Re_Com.f virt_pions/tensor_redux_Cij_new_Re_Com_G.f virt_pions/tensor_redux_Dij_new_Re_Com_G.f virt_pions/test_vFSRcr.f  hard_soft_part/ISRcurrent_no_mass_terms.f
+CXX=g++
+
+FCFLAGS=--std=f2008 -O2 -Wall -fPIC -I.
+CXXFLAGS=--std=c++17 -O2 -Wall -fPIC
+
+test_SOURCES = virtualpions.f momenta_quad.f virt_pions/prog.f virt_pions/dotprod_QUAD.f virt_pions/tensor_redux_Bij_new_Re_Com_QUAD.f virt_pions/tensor_redux_Cij_new_Re_Com_G_QUAD.f virt_pions/tensor_redux_Dij_new_Re_Com_G_QUAD.f virt_pions/tensor_redux_Eij_new_Re_Com_G_QUAD_Pentabox.f virt_pions/QUADE0FunctionsG.f virt_pions/Pentabox_full_isrHelSum_temp.f virt_pions/cross_ISRHelSum_temp.f virt_pions/Pentabox_PIFSRHelSum_temp.f virt_pions/cross_FSRHelSum_temp.f  hard_soft_part/one_photon.f hard_soft_part/soft_integrals.f virt_pions/test_vFSR.f virt_pions/dotprod.f virt_pions/tensor_redux_Bij_new_Re_Com.f virt_pions/tensor_redux_Cij_new_Re_Com_G.f virt_pions/tensor_redux_Dij_new_Re_Com_G.f virt_pions/test_vFSRcr.f  hard_soft_part/ISRcurrent_no_mass_terms.f belle2event.f gammf64.f
 test_OBJECTS := $(test_SOURCES:%.f=%.o)
+F90SOURCES = belle2_phokhara_interface.f90
+F90OBJECTS := $(F90SOURCES:%.f90=%.o)
 
 # Change path to compile to $HOME/new_path
 
 # Path to libqcdloop1.so and libpjfry.so
-LIBDIR=/home/szymon/PH10.0/eemmg-lib
+LIBDIR=$(EEMMGLIB_PATH)
 # Path to libeemmg5.so
-LIBDIR1=/home/szymon/PH10.0/eemmg-lib
+LIBDIR1=$(EEMMGLIB_PATH)
 # Path to libeemmgisr.so
-LIBDIR2=/home/szymon/PH10.0/eemmg-lib
+LIBDIR2=$(EEMMGLIB_PATH)
 # Path to lqcdloop1
-LIBDIR3=/home/szymon/PH10.0/eemmg-lib
-LIBDIR4=/home/szymon/PH10.0/eemmg-lib
+LIBDIR3=$(EEMMGLIB_PATH)
+LIBDIR4=$(EEMMGLIB_PATH)
 # Path to fort 11 libraries
-LIBDIR5=/home/szymon/PH10.0/eemmg-lib
+LIBDIR5=$(EEMMGLIB_PATH)
 
 # Link eemmg
-LINK=-L$(LIBDIR1) -L$(LIBDIR2) -L$(LIBDIR) -L$(LIBDIR3) -L$(LIBDIR4) -L$(LIBDIR5) -leemmg5 -leemmgisr -lpjfry -lqcdloop1 -leemmgisrfsr -leemmgmix
+LINK=-L$(LIBDIR1) -L$(LIBDIR2) -L$(LIBDIR) -L$(LIBDIR3) -L$(LIBDIR4) -L$(LIBDIR5) -leemmg5 -leemmgisr -lpjfry -lqcdloop1 -leemmgisrfsr -leemmgmix -lstdc++
 
 
 # 
-# Linking cernlib
-LINKCERN=-L/usr/bin/cernlib -lkernlib -lmathlib -lpacklib
+# Linking ROOT
+ROOT_INCLUDE_FLAGS=-I$(ROOTSYS)/include
+ROOT_LINK_FLAGS=-L$(ROOTSYS)/lib -lCore
 
-all: phokhara
+all: libphokhara.so
 
 test: testlxf
 	./testlxf
@@ -37,8 +45,14 @@ run:
 	$(F77) -c testlxf.for
 	$(F77) -c seed_prod.for
 
-phokhara: ranlux_fort.o ranlxd.o phokhara_10.0.o $(OBJ) $(test_OBJECTS) $(LIBDIR)/libqcdloop1.so    
-	LD_LIBRARY_PATH=$(LIBDIR) $(F77)  -o $@ $^ $(LINKCERN) $(LINK) 
+%.o: %.f90
+	$(FC) $(FCFLAGS) -c -o $@ $^
+
+%.o: %.cc
+	$(CXX) $(CXXFLAGS) $(ROOT_INCLUDE_FLAGS) -c -o $@ $^
+
+libphokhara.so: random.o $(OBJ) $(test_OBJECTS) $(F90OBJECTS) $(LIBDIR)/libqcdloop1.so phokhara_10.0.o
+	LD_LIBRARY_PATH=$(LIBDIR) $(CXX) -shared -Wl,--version-script=libphokhara.vers -o $@ $^ $(ROOT_LINK_FLAGS) $(LINK)
 
 testlxf: testlxf.o ranlux_fort.o ranlxd.o
 	$(F77) -o $@ $^
@@ -47,5 +61,5 @@ seed_prod: seed_prod.o ranlux_fort.o ranlxd.o
 	$(F77) -o $@ $^
 
 clean:
-	rm -f *.o phokhara seed_prod testlxf
+	rm -f *.o libphokhara.so seed_prod testlxf
 
diff --git a/belle2_phokhara_interface.f90 b/belle2_phokhara_interface.f90
new file mode 100644
index 0000000..66dc99b
--- /dev/null
+++ b/belle2_phokhara_interface.f90
@@ -0,0 +1,89 @@
+
+MODULE BELLE2_PHOKHARA_INTERFACE
+  IMPLICIT NONE
+
+  TYPE PHOKHARA_PARAMETERS
+    CHARACTER(LEN=:), ALLOCATABLE :: PARAMETER_FILE
+    CHARACTER(LEN=:), ALLOCATABLE :: INPUT_FILE
+  CONTAINS
+    FINAL :: PHOKHARA_PARAMETERS_DESTRUCTOR
+  END TYPE
+
+  TYPE(PHOKHARA_PARAMETERS) BELLE2_PHOKHARA_PARAMETERS
+
+  INTERFACE RANLXDF
+    SUBROUTINE RANLXDF_ARRAY(ARRAY, N) BIND(C, NAME="phokhara_rndmarray")
+      USE, INTRINSIC :: ISO_C_BINDING
+      IMPLICIT NONE
+      INTEGER(C_INT), INTENT(IN) :: N
+      REAL(C_DOUBLE), INTENT(OUT), DIMENSION(N) :: ARRAY
+    END SUBROUTINE
+    SUBROUTINE RANLXDF_ARRAY_SCALAR(VAL, N) BIND(C, NAME="phokhara_rndmarray")
+      USE, INTRINSIC :: ISO_C_BINDING
+      IMPLICIT NONE
+      INTEGER(C_INT), INTENT(IN) :: N
+      REAL(C_DOUBLE), INTENT(OUT) :: VAL
+    END SUBROUTINE
+  END INTERFACE
+
+CONTAINS
+
+  SUBROUTINE PHOKHARA_PARAMETERS_DESTRUCTOR(SELF)
+    IMPLICIT NONE
+    TYPE(PHOKHARA_PARAMETERS), INTENT(INOUT) :: SELF
+    IF (ALLOCATED(SELF%PARAMETER_FILE)) THEN
+      DEALLOCATE(SELF%PARAMETER_FILE)
+    ENDIF
+    IF (ALLOCATED(SELF%INPUT_FILE)) THEN
+      DEALLOCATE(SELF%INPUT_FILE)
+    ENDIF
+  END SUBROUTINE
+
+  SUBROUTINE CONVERT_STRING(C_STRING, FORTRAN_STRING)
+    USE, INTRINSIC :: ISO_C_BINDING
+    USE, INTRINSIC :: ISO_FORTRAN_ENV
+    IMPLICIT NONE
+    CHARACTER(C_CHAR), INTENT(IN), DIMENSION(*) :: C_STRING
+    CHARACTER(LEN=:), INTENT(OUT), ALLOCATABLE :: FORTRAN_STRING
+    INTEGER I, L, RES
+    LOGICAL EMPTY_STRING
+    L = 0
+    DO WHILE (C_STRING(L + 1) /= C_NULL_CHAR)
+      L = L + 1
+    ENDDO
+    IF (L == 0) THEN
+      L = 1
+      EMPTY_STRING = .TRUE.
+    ELSE
+      EMPTY_STRING = .FALSE.
+    ENDIF
+    ALLOCATE(CHARACTER(LEN = L) :: FORTRAN_STRING, STAT = RES)
+    IF (RES /= 0) THEN
+      WRITE(ERROR_UNIT, '(A)') 'Memory allocation error.'
+      RETURN
+    ENDIF
+    IF (EMPTY_STRING) THEN
+      FORTRAN_STRING(1:1) = ' '
+    ELSE
+      DO I = 1, L
+        FORTRAN_STRING(I:I) = C_STRING(I)
+      ENDDO
+    ENDIF
+  END SUBROUTINE
+
+  SUBROUTINE PHOKHARA_SET_PARAMETER_FILE(PARAMETER_FILE) BIND(C)
+    USE, INTRINSIC :: ISO_C_BINDING
+    IMPLICIT NONE
+    CHARACTER(C_CHAR), INTENT(IN), DIMENSION(*) :: PARAMETER_FILE
+    CALL CONVERT_STRING(PARAMETER_FILE, &
+&     BELLE2_PHOKHARA_PARAMETERS%PARAMETER_FILE)
+  END SUBROUTINE
+
+  SUBROUTINE PHOKHARA_SET_INPUT_FILE(INPUT_FILE) BIND(C)
+    USE, INTRINSIC :: ISO_C_BINDING
+    IMPLICIT NONE
+    CHARACTER(C_CHAR), INTENT(IN), DIMENSION(*) :: INPUT_FILE
+    CALL CONVERT_STRING(INPUT_FILE, BELLE2_PHOKHARA_PARAMETERS%INPUT_FILE)
+  END SUBROUTINE
+
+END MODULE
diff --git a/belle2event.f b/belle2event.f
new file mode 100644
index 0000000..1ada99b
--- /dev/null
+++ b/belle2event.f
@@ -0,0 +1,198 @@
+c =================================================
+c --- convert output to four vectors for basf2 ----
+c =================================================
+c
+      subroutine belle2event()
+      include 'phokhara_10.0.inc'
+           
+      integer ii
+      integer BNPHOT,BNHAD
+      double precision BP1(0:3),BQ1(0:3),BP2(0:9,0:5),BPHOT(0:1,0:3)
+      COMMON / MOMSET / BP1,BQ1,BP2,BPHOT,BNPHOT,BNHAD
+      
+      BNPHOT = 0
+      BNHAD = 0
+      
+!       electron (e-) (+z direction)
+      do ii=0,3
+	BP1(ii) = momenta(1,ii)
+      enddo
+!       positron (e+) (-z direction)
+      do ii=0,3
+	BQ1(ii) = momenta(2,ii)
+      enddo      
+      
+!       photon 1
+      if(momenta(3,0).gt.0.0)then !(ii,0) is energy, (ii,3) is pz!
+      	do ii=0,3
+	  BPHOT(0,ii) = momenta(3,ii)
+        enddo
+        BNPHOT = BNPHOT + 1
+      endif
+!       photon 2
+      if(momenta(4,0).gt.0.0)then
+      	do ii=0,3
+	  BPHOT(1,ii) = momenta(4,ii)
+        enddo
+        BNPHOT = BNPHOT + 1
+      endif
+            
+!       all the rest...
+      if (pion.eq.0) then !mu+ mu-
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = -13 !mu+
+	BP2(1,4) = 13  !mu-
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BNHAD = 2
+        
+      elseif(pion.eq.1)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = 211  !pi+
+	BP2(1,4) = -211 !pi-
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BNHAD = 2
+                
+      elseif(pion.eq.2)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+	  BP2(2,ii) = momenta(8,ii)
+	  BP2(3,ii) = momenta(9,ii)
+        enddo
+        BP2(0,4) = 111  !pi0
+	BP2(1,4) = 111  !pi0
+	BP2(2,4) = -211 !pi-
+	BP2(3,4) = 211  !pi+
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BP2(2,5) = -1
+	BP2(3,5) = -1
+        BNHAD = 4
+        
+      elseif(pion.eq.3)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+	  BP2(2,ii) = momenta(8,ii)
+	  BP2(3,ii) = momenta(9,ii)
+        enddo
+        BP2(0,4) = 211  !pi+
+	BP2(1,4) = -211 !pi-
+	BP2(2,4) = -211 !pi-
+	BP2(3,4) = 211  !pi+
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BP2(2,5) = -1
+	BP2(3,5) = -1
+        BNHAD = 4
+
+      elseif(pion.eq.4)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = -2212  !Pbar
+	BP2(1,4) = 2212 !P
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BNHAD = 2
+        
+      elseif(pion.eq.5)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = -2112  !Nbar
+	BP2(1,4) = 2112 !N
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+        BNHAD = 2
+        
+      elseif(pion.eq.6)then
+        do ii=0,3
+          BP2(0,ii) = momenta(6,ii)
+          BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = 321  !K+
+        BP2(1,4) = -321 !K-
+        BP2(0,5) = -1
+        BP2(1,5) = -1
+        BNHAD = 2
+
+      elseif(pion.eq.7)then
+C       Kevin Varvell - Output KL and KS rather than K0 K0bar
+        do ii=0,3
+          BP2(0,ii) = momenta(6,ii)
+          BP2(1,ii) = momenta(7,ii)
+        enddo
+        BP2(0,4) = 130  !KL
+        BP2(1,4) = 310  !KS
+        BP2(0,5) = -1
+        BP2(1,5) = -1
+        BNHAD = 2
+        
+      elseif(pion.eq.8)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+	  BP2(2,ii) = momenta(8,ii)
+        enddo
+        BP2(0,4) = 211  !Pi+
+	BP2(1,4) = -211 !Pi-
+	BP2(2,4) = 111 !Pi0
+        BP2(0,5) = -1
+	BP2(1,5) = -1
+	BP2(2,5) = -1
+        BNHAD = 3
+        
+      elseif(pion.eq.9)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+	  BP2(2,ii) = momenta(8,ii)
+	  BP2(3,ii) = momenta(9,ii)
+	  BP2(4,ii) = momenta(10,ii)
+	  BP2(5,ii) = momenta(11,ii)
+        enddo
+        BP2(0,4) = -3122  !Lambda bar
+	BP2(1,4) = 3122 !Lambda
+	BP2(2,4) = 211 !pi+
+	BP2(3,4) = -2212 !Pbar
+	BP2(4,4) = -211 !pi-
+	BP2(5,4) = 2212 !P
+	BP2(0,5) = -1
+	BP2(1,5) = -1
+	BP2(2,5) = 0
+	BP2(3,5) = 0
+	BP2(4,5) = 1
+	BP2(5,5) = 1
+        BNHAD = 6
+        
+      elseif(pion.eq.10)then
+	do ii=0,3
+	  BP2(0,ii) = momenta(6,ii)
+	  BP2(1,ii) = momenta(7,ii)
+	  BP2(2,ii) = momenta(8,ii)
+        enddo
+        BP2(0,4) = 221  !eta
+	BP2(1,4) = 211  !pi+
+	BP2(2,4) = -211 !pi-
+	BP2(0,5) = -1
+	BP2(1,5) = -1
+	BP2(2,5) = -1
+        BNHAD = 3
+
+      else
+        continue
+      endif
+      
+      return
+      end
diff --git a/eemmg-lib/Makefile.inc b/eemmg-lib/Makefile.inc
index 65b910c..c8b61fb 100644
--- a/eemmg-lib/Makefile.inc
+++ b/eemmg-lib/Makefile.inc
@@ -6,7 +6,7 @@ F77 = gfortran
 
 # create dynamic libraries
 CXXFLAGS = -O2 -fPIC -DHAVE_CONFIG_H
-FFLAGS = -O2 -fPIC -ff2c
+FFLAGS = -O2 -std=legacy -fPIC -ff2c
 LIB_LDFLAGS = -shared -Wl,-no-undefined -Wl,-export-dynamic
 BIN_LDFLAGS = -Wl,-rpath=.
 LIBEXT=.so
diff --git a/gammf64.f b/gammf64.f
new file mode 100644
index 0000000..de95113
--- /dev/null
+++ b/gammf64.f
@@ -0,0 +1,69 @@
+
+! From CERNLIB 2006.
+! mathlib/gen/c/gammf64.F
+
+      FUNCTION DGAMMF(X)
+C
+      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+C
+      CHARACTER*(*) NAME
+      PARAMETER(NAME='GAMMF/DGAMMF')
+      CHARACTER*80 ERRTXT
+C
+      DIMENSION C(0:15)
+
+      PARAMETER (PI = 3.14159 26535 89793 24D0)
+
+      DATA C( 0) /3.65738 77250 83382 44D0/
+      DATA C( 1) /1.95754 34566 61268 27D0/
+      DATA C( 2) /0.33829 71138 26160 39D0/
+      DATA C( 3) /0.04208 95127 65575 49D0/
+      DATA C( 4) /0.00428 76504 82129 09D0/
+      DATA C( 5) /0.00036 52121 69294 62D0/
+      DATA C( 6) /0.00002 74006 42226 42D0/
+      DATA C( 7) /0.00000 18124 02333 65D0/
+      DATA C( 8) /0.00000 01096 57758 66D0/
+      DATA C( 9) /0.00000 00059 87184 05D0/
+      DATA C(10) /0.00000 00003 07690 81D0/
+      DATA C(11) /0.00000 00000 14317 93D0/
+      DATA C(12) /0.00000 00000 00651 09D0/
+      DATA C(13) /0.00000 00000 00025 96D0/
+      DATA C(14) /0.00000 00000 00001 11D0/
+      DATA C(15) /0.00000 00000 00000 04D0/
+
+      U=X
+      IF(U .LE. 0) THEN
+       IF(U .EQ. INT(X)) THEN
+!        WRITE(ERRTXT,101) U
+!        CALL MTLPRT(NAME,'C303.1',ERRTXT)
+        H=0
+        GO TO 9
+       ELSE
+        U=1-X
+       END IF
+      ENDIF
+    8 F=1
+      IF(U .LT. 3) THEN
+       DO 1 I = 1,INT(4-U)
+       F=F/U
+    1  U=U+1
+      ELSE
+       DO 2 I = 1,INT(U-3)
+       U=U-1
+    2  F=F*U
+      END IF
+      H=U+U-7
+      ALFA=H+H
+      B1=0
+      B2=0
+      DO 3 I = 15,0,-1
+      B0=C(I)+ALFA*B1-B2
+      B2=B1
+    3 B1=B0
+      H=F*(B0-H*B2)
+      IF(X .LT. 0) H=PI/(SIN(PI*X)*H)
+    9 DGAMMF=H
+      RETURN
+
+  101 FORMAT('ARGUMENT IS NON-POSITIVE INTEGER = ',1P,E15.1)
+      END
diff --git a/libphokhara.vers b/libphokhara.vers
new file mode 100644
index 0000000..c80ee5d
--- /dev/null
+++ b/libphokhara.vers
@@ -0,0 +1,9 @@
+libphokhara {
+    global:
+        momset_;
+        phokhara;
+        phokhara_set_parameter_file;
+        phokhara_set_input_file;
+    local:
+        *;
+};
diff --git a/phokhara_10.0.f b/phokhara_10.0.f
index 4d11ba7..a9d5fd5 100644
--- a/phokhara_10.0.f
+++ b/phokhara_10.0.f
@@ -206,17 +206,49 @@ c ======================================================================== c
 c  version 10.0: (c) November 2018,  http://ific.uv.es/~rodrigo/phokhara/  c
 c ======================================================================== c
 
+      subroutine phokhara(MODE,XPAR,NPAR) bind(c) !TF added subroutine and parameters for extern C call
+      use, intrinsic :: iso_c_binding
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
+
+      integer(c_int) MODE !TF, steering of weight calculation, generation and finalization
+      real(c_double) XPAR(0:99) !TF, real parameters
+      integer(c_int) NPAR(0:99) !TF, integer parameters
+
+      integer BNPHOT,BNHAD !TF
+      double precision BP1(0:3),BQ1(0:3),BP2(0:9,0:5),BPHOT(0:1,0:3) !TF
+      COMMON / MOMSET / BP1,BQ1,BP2,BPHOT,BNPHOT,BNHAD !TF
+
       real*8 qqmin,qqmax,
      &  cos1min,cos1max,cos2min,cos2max,cos3min,cos3max,
      &  dsigm1,dsigm2,sigma1,sigma2,sigma,dsigm,Ar(14),Ar_r(0:13),
      &   sigma0,dsigm0
+
+      real*8 cqqmin,cqqmax,
+     &  ccos1min,ccos1max,ccos2min,ccos2max,ccos3min,ccos3max
+      common / kin / cqqmin,cqqmax,
+     &  ccos1min,ccos1max,ccos2min,ccos2max,ccos3min,ccos3max !TF
+
       real*8 int2ph,int2ph_err,inte,inte_s,int1ph,
      & int1ph_err,intezero,int0ph,int0ph_err
       real*8 sum_MC,sum_MC_err,energi_m
       integer nm,i,s_seed(0:104)
       integer*8 nges,k,j,n_ph
       character outfile*20
+
+      integer nmaxtrials !TF
+      common / maxtrials / nmaxtrials !TF
+      integer nmaxsearch !TF
+      common / maxsearch / nmaxsearch !TF
+      common / eventcount / nges !TF
+
+      common / intsigma / int2ph,int2ph_err,int1ph,
+     & int1ph_err,int0ph,int0ph_err !T
+
+      integer acc !TF
+      
+      real*8 ecm !TF
+      common / beam / ecm !TF
 c
       common/muonfsr/inte
       common/virtsoft/inte_s
@@ -227,20 +259,51 @@ c
 c      open(16,file='cross1.dat',ACCESS='append')
 c      open(17,file='cross2.dat',ACCESS='append')
 c --- reads the seed ------
-      open(9,file='seed.dat',status='old')
-      open(10,file='phokhara.out')!,status='new')
-      read(9,*)s_seed
-      call rlxdresetf(s_seed)
+c      open(9,file='seed.dat',status='old')
+c      open(10,file='phokhara.out')!,status='new')
+c      read(9,*)s_seed
+c      call rlxdresetf(s_seed)
 c      call rlxdinit(1,32767)    
 c --- input parameters ----------------------------
       
 
-      call input(nges,nm,outfile)
+      if(MODE.eq.-1)then
+      
+        nmaxtrials = NPAR(1)  ! maximum number of trials per event
+        nmaxsearch = NPAR(2)  ! events used to search cross section maximum
+        pion       = NPAR(20) ! final state (very intuitive name...)
+        ph0        = NPAR(30) ! Born: 1ph(0)radiative return; Born: 0ph(1) scan
+        nlo        = NPAR(31) ! radiative return mode: Born(0), NLO(1)
+        fsr        = NPAR(32) ! ISR only(0), ISR+FSR(1), ISR+INT+FSR(2)
+        fsrnlo     = NPAR(33) ! yes(1), no(0)
+        ivac       = NPAR(34) ! no(0),yes; by Fred Jegerlehner(1),yes;by Thomas Teubner(2)
+        FF_Pion    = NPAR(35) ! KS Pionformfactor(0), GS Pionformfactor(1) old, GS Pionformfactor new(2)
+        FF_kaon    = NPAR(36) ! KaonFormFactor constrained (0),KaonFormFactor unconstrained (1),KaonFormFactor old (2)
+        f0_model   = NPAR(37) ! f0+f0(600): KK model(0), no structure(1), no f0+f0(600)(2), f0 KLOE(3)
+        narr_res   = NPAR(38) ! no narrow resonances (0), J/Psi (1), Psi(2S) (2) (narro resonances only for pion = 0, 1, 6, 7
+        FF_pp      = NPAR(39) ! ProtonFormFactor old(0), ProtonFormFactor new(1)        
+        
+        ecm        = XPAR(0)  ! CMS energy
+        w          = XPAR(11) ! soft photon cutoff
+        q2min      = XPAR(15) ! minimal  hadrons(muons)-gamma-inv mass squared 
+        q2_min_c   = XPAR(16) ! minimal inv. mass squared of the hadrons(muons)
+        q2_max_c   = XPAR(17) ! maximal inv. mass squared of the hadrons(muons)
+        gmin       = XPAR(18) ! minimal photon energy/missing energy
+        phot1cut   = XPAR(20) ! minimal photon angle/missing momentum angle
+        phot2cut   = XPAR(21) ! maximal photon angle/missing momentum angle
+        pi1cut     = XPAR(22) ! minimal hadrons(muons) angle
+        pi2cut     = XPAR(23) ! maximal hadrons(muons) angle
+       
+        call input(nges,nm,outfile)
+
+        nges=0
+      endif
 c      energi_m=sqrt(Sp)
 
 c --- open output file for generated momenta ------
-      if(iprint.ne.0) open (10,file=outfile,status='new')
+!      if(iprint.ne.0) open (10,file=outfile,status='new')
 
+      if(MODE.eq.-1) then
 c --- print run data ------------------------------
       write(*,*) '----------------------------------------------------'
       write(10,*) '----------------------------------------------------'
@@ -514,8 +577,8 @@ c --------------------------------
       endif
 c
 c --- book histograms -----------------------------
-      call inithisto
-      call inithistoMC
+c      call inithisto
+c      call inithistoMC
 c --- set cuts ------------------------------------
       cos1min = dCos(phot2cut*pi/180.d0)     ! photon1 angle cuts in the 
       cos1max = dCos(phot1cut*pi/180.d0)     ! LAB rest frame            
@@ -1215,10 +1278,23 @@ c --------------------
         endif
       endif
 
+c --- TF copy some of them to the common block ------
+        cqqmin   = qqmin
+        cqqmax   = qqmax
+        ccos1min = cos1min
+        ccos1max = cos1max
+        ccos2min = cos2min
+        ccos2max = cos2max
+        ccos3min = cos3min
+        ccos3max = cos3max
+
+      endif !endif MODE.e1.-1
+
 c
 c =================================================
 c --- finding the maximum -------------------------
-      k = nm                        
+      if(MODE.eq.-1)then
+
       do i = 1,3
          Mmax(i-1) = 1.d0
          gross(i-1) = 0.d0
@@ -1229,8 +1305,15 @@ c --- finding the maximum -------------------------
       if  (ph0.eq.-1)then   ! only 0 photon events (LO) are generated
          Mmax(1)=0.d0  
          Mmax(2)=0.d0 
-      endif    
-      do i = 1,2        ! initializing the MC loop
+      endif      
+      
+      endif!TF endif MODE.eq.-1
+
+
+c =================================================
+      if(MODE.eq.-1)then
+      i=1
+      
       tr(0) = 0.d0
       tr(1) = 0.d0      
       tr(2) = 0.d0
@@ -1252,14 +1335,14 @@ c
 c =================================================
 c --- beginning the MC loop event generation ------
       
-      do j = 1,k
+      do j = 1,nmaxsearch
           
          call ranlxdf(Ar_r,1)
          Ar(1) = Ar_r(0)
  
          if (Ar(1).le.(Mmax(0)/(Mmax(1)+Mmax(2)+Mmax(0)))) then 
             count(0)=count(0)+1
-            call gen_0ph(i,qqmin,Sp,cos3min,cos3max)
+            call gen_0ph(i,qqmin,Sp,cos3min,cos3max,acc)
            int0ph = int0ph + intezero
            int0ph_err = int0ph_err + intezero*intezero
          elseif(Ar(1).le.(Mmax(0)+Mmax(1))
@@ -1267,7 +1350,7 @@ c --- beginning the MC loop event generation ------
             
             count(1) = count(1)+1.d0
             call gen_1ph(i,qqmin,qqmax,cos1min,cos1max,
-     &	         cos3min,cos3max)
+     &          cos3min,cos3max,acc)
             
    
          int1ph=int1ph + inte_s
@@ -1277,7 +1360,7 @@ c --- beginning the MC loop event generation ------
          else
             count(2) = count(2)+1.d0
             call gen_2ph(i,qqmin,cos1min,cos1max,
-     &           cos2min,cos2max,cos3min,cos3max)
+     &           cos2min,cos2max,cos3min,cos3max,acc)
            int2ph=int2ph + inte
            int2ph_err=int2ph_err + inte*inte
          endif
@@ -1289,7 +1372,6 @@ c --- end of the MC loop --------------------------
 
 c =================================================
 c --- for the second run ---
-      k = nges
       if (i.eq.1) then
          Mmax(0) = gross(0)+.1d0*Sqrt(gross(0)*gross(0))
          Mmax(1) = gross(1)+.05d0*Sqrt(gross(1)*gross(1))
@@ -1314,18 +1396,82 @@ c
             Mmax(1)=Mmax(1)*1.5d0
          endif
       endif
-      enddo    
-        
-c --- end of the second run -----------------------
+
+      tr(0) = 0.d0
+      tr(1) = 0.d0
+      tr(2) = 0.d0
+
+      count(0) = 0.d0
+      count(1) = 0.d0
+      count(2) = 0.d0
+c
+      int2ph = 0.d0
+      int2ph_err = 0.d0
+c
+      int1ph=0.d0
+      int1ph_err=0.d0
+c
+      int0ph = 0d0
+      int0ph_err = 0d0
+
+      nges=0 !TF number of generated events
+
+      endif !TF MODE.eq.-1
+
 c =================================================
-     
+      if(MODE.eq.1)then
+      i=2
+
+      do j = 1,nmaxtrials
+
+         call ranlxdf(Ar_r,1)
+         Ar(1) = Ar_r(0)
+
+         acc=0
+
+         if (Ar(1).le.(Mmax(0)/(Mmax(1)+Mmax(2)+Mmax(0)))) then
+            count(0)=count(0)+1
+            call gen_0ph(i,cqqmin,Sp,ccos3min,ccos3max,acc)
+           int0ph = int0ph + intezero
+           int0ph_err = int0ph_err + intezero*intezero
+         elseif(Ar(1).le.(Mmax(0)+Mmax(1))
+     &            /(Mmax(1)+Mmax(2)+Mmax(0)))then
+            count(1) = count(1)+1.d0
+            call gen_1ph(i,cqqmin,cqqmax,ccos1min,ccos1max,
+     &          ccos3min,ccos3max,acc)
+c
+         int1ph=int1ph + inte_s
+         int1ph_err=int1ph_err + inte_s*inte_s
+c
+         else
+            count(2) = count(2)+1.d0
+            call gen_2ph(i,cqqmin,ccos1min,ccos1max,
+     &           ccos2min,ccos2max,ccos3min,ccos3max,acc)
+           int2ph=int2ph + inte
+           int2ph_err=int2ph_err + inte*inte
+         endif
+
+         nges=nges+1
+
+         if(acc.eq.1) then
+           call belle2event
+           goto 600
+         endif
+
+      enddo
+
+      endif !TF MODE.eq.1
+
+
+      if(MODE.eq.2)then
+
       if(pion.eq.9)then
          Mmax(0) = Mmax(0) * (1.d0 + alpha_lamb)**2 * ratio_lamb**2
          Mmax(1) = Mmax(1) * (1.d0 + alpha_lamb)**2 * ratio_lamb**2
       endif 
 c --- save histograms -----------------------------
-      call endhisto()
-      if(pion.ne.9) call endhistoMC()
+c      call endhisto()
+c      if(pion.ne.9) call endhistoMC()
 c --- value of the cross section ------------------
       sigma0 = 0.d0
       sigma1 = 0.d0
@@ -1478,6 +1624,10 @@ c
       write(10,200)'sigma2_MC(nbarn) = ',int2ph,'+-',int2ph_err
       write(10,200)'sigma_MC (nbarn) = ',sum_MC,'+-',sum_MC_err
       endif
+
+      endif !TF end MODE.eq.2
+      
+ 600  continue     
        
 c      write(17,*) energi_m,sum_MC,sum_MC_err,int0ph,int0ph_err,
 c     1 int1ph,int1ph_err
@@ -1530,6 +1680,7 @@ c Mode    p + pbar (pion=4)         |   q1 - four momentum of pi^+
 c Mode    n + nbar (pion=5)         |   q2 - four momentum of pi^-
 c Mode    K^+ + K^-(pion=6)         |   q3 - four momentum of pi^0
 c Mode    K^0 + K^0bar (pion=7)
+c                        note that for 7: KL KS is written out
 c
 c Mode  lambda (-> pi^- p) lambda bar (-> pi^+ pbar) (pion=9)
 c Mode eta pi+  pi-  (pion=10)
@@ -1588,9 +1739,9 @@ c
          write(10,*)'K-:    ',momenta(7,0),momenta(7,1),
      &      momenta(7,2),momenta(7,3)
       elseif(pion.eq.7)then
-         write(10,*)'K0:    ',momenta(6,0),momenta(6,1),
+         write(10,*)'KL:    ',momenta(6,0),momenta(6,1),
      &      momenta(6,2),momenta(6,3)
-         write(10,*)'K0bar:    ',momenta(7,0),momenta(7,1),
+         write(10,*)'KS:    ',momenta(7,0),momenta(7,1),
      &      momenta(7,2),momenta(7,3)
       elseif(pion.eq.8)then
          write(10,*)'Pi+:    ',momenta(6,0),momenta(6,1),
@@ -1648,7 +1799,8 @@ c
 c ======================================================================
 c --- generates 0 photon ---------------------------------------------
 c ======================================================================
-      subroutine gen_0ph(i,qqmin,qqmax,cos3min,cos3max)
+      subroutine gen_0ph(i,qqmin,qqmax,cos3min,cos3max,acc)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       real*8 Ar(14),Ar_r(0:13),z,inte,amplit,pom
       real*8 qqmin,qqmax,qq,jac4,helicityampLO,Matrix 
@@ -1658,12 +1810,15 @@ c ======================================================================
       complex*16 Hadronic(0:3,0:3),pionggFF_dprime
       integer i,ru,ll
       logical accepted    
+      integer acc
       common/zeroph/intezero
       call ranlxdf(Ar_r,7)
       do ru=0,6
        Ar(ru+1)=Ar_r(ru)
       enddo  
 
+      acc = 0
+
 c --- get the variables ---------------------------
 c
        call qquadrat_0(qqmin,qqmax,cos3min,cos3max,Ar
@@ -1732,6 +1887,7 @@ c --- event accepted? ---
                      tr(0) = tr(0) + 1.d0
                      call addiere(1.d0,qq,0)
                      if (iprint.ne.0) call writeevent()
+                     acc = 1
                    endif
                else
                tr(0) = tr(0) + 1.d0 
@@ -1745,6 +1901,7 @@ c polar angle distribution
      &         dSqrt(momenta(7,1)**2+momenta(7,2)**2+momenta(7,3)**2)
               call addiere(1.d0,pom,4) ! cos(th-)
               if (iprint.ne.0) call writeevent()
+              acc = 1
               endif
          endif
          endif    
@@ -1759,7 +1916,8 @@ c ======================================================================
 c --- generates one photon ---------------------------------------------
 c ======================================================================
       subroutine gen_1ph(i,qqmin,qqmax,cos1min,cos1max,
-     &                   cos3min,cos3max)
+     &                   cos3min,cos3max,acc)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       complex*16 Leptonic(0:3,0:3),Hadronic(0:3,0:3),
      1 Leptonic2(0:3,0:3),Hadronic2(0:3,0:3),
@@ -1777,6 +1935,7 @@ c ======================================================================
       complex*16 fsr_no_em
       integer i,ru,mu,nu
       logical accepted      
+      integer acc
       common/Lept_ee/Leptonic
       common/pedf/rk1,dps 
       common/virtsoft/inte_s
@@ -1802,6 +1961,8 @@ c
        call addiere(1.d0,momenta(2,0),7)
        call addiere(1.d0,momenta(2,0)+momenta(1,0),8)     
 
+      acc = 0
+
 c --- get the variables ---------------------------
 
       if((pion.eq.13).or.(pion.eq.14).or.(pion.eq.15))then  
@@ -1957,6 +2118,7 @@ c --- event accepted? ---
                      tr(1) = tr(1) + 1.d0
                      call addiere(1.d0,qq,1)
                     if (iprint.ne.0) call writeevent()
+                    acc = 1
                  endif
                else
                   tr(1) = tr(1) + 1.d0
@@ -1981,7 +2143,7 @@ c        endif
               call addiere(1.d0,pom,4) ! cos(th-)
 
                 if (iprint.ne.0) call writeevent()
-
+                acc = 1
                endif
             endif 
 
@@ -1997,7 +2159,8 @@ c ======================================================================
 c --- generates two photons --------------------------------------------
 c ======================================================================
       subroutine gen_2ph(i,qqmin,cos1min,cos1max,
-     &   cos2min,cos2max,cos3min,cos3max)
+     &   cos2min,cos2max,cos3min,cos3max,acc)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       real*8 qqmin,qqmax,qq,jac0,q0p,q2p,q0b,q2b,
      &  cos1min,cos1max,cos1,phi1,jac1,sin1,cos12,
@@ -2006,6 +2169,7 @@ c ======================================================================
      &  Ar(14),Ar_r(0:14),z,inte,helicityamp,pom
       integer i,ru
       logical accepted    
+      integer acc
 c  
       common/muonfsr/inte
 c
@@ -2014,6 +2178,8 @@ c
          Ar(ru+1) = Ar_r(ru)
       enddo
       
+      acc = 0
+
 c --- get the variables -----------------------------------------------
 c --- one of the photons is generated inside the angular cuts and -----
 c --- the other is generated everywhere -------------------------------
@@ -2094,6 +2260,7 @@ c --- event accepted? ---
             if (z.le.inte) then
                   tr(2) = tr(2) + 1.d0
                if (iprint.ne.0) call writeevent()
+               acc = 1
 c --- add to the histogrammes ---
                call addiere(1.d0,qq,2)
 c polar angle distribution
@@ -2115,6 +2282,7 @@ c ======================================================================
 c --- input parameters -------------------------------------------------
 c ======================================================================
       subroutine input(nges,nm,outfile)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       integer nm,i,jj,kk,ii
       integer*8 nges
@@ -2181,54 +2349,56 @@ c J/Psi and Psi(2S) generation common
       
         
        
-      
+      real*8 ecm !TF
+      common / beam / ecm !TF
 c
 c --- input file ---------------------------------
-      open(7,file='input_10.0.dat',status='old')
-      open(8,file='const_and_model_paramall10.0.dat',status='old')
+!      open(7,file=belle2_phokhara_parameters%input_file,status='old')
+      open(8,file=belle2_phokhara_parameters%parameter_file,
+     &  status='old')
 c --- input generation parameters ----------------
-      read(7,*)           !                                   
-      read(7,*) nges      ! number of generated events        
-      read(7,*) nm        ! events to determine the maximum   
-      read(7,*) outfile   ! output file                       
-      read(7,*) iprint    ! printing(1), nonprinting(0) generated events
-      read(7,*) ph0       ! Born: 1ph(0)radiative return; Born: 0ph(1) scan
-      read(7,*) nlo       ! radiative return mode: Born(0), NLO(1)
-      read(7,*) nlo2      ! full NLO: No(0), Yes(1)
-      read(7,*) w         ! soft photon cutoff                
-      read(7,*) pion      ! mu+mu-(0),pi+pi-(1),2pi0pi+pi-(2),2pi+2pi-(3),ppbar(4),nnbar(5),K+K-(6),K0K0bar(7),pi+pi-pi0(8), Lamb Lambbar->pi-pi+ppbar(9) 
-      read(7,*) fsr       ! ISR only(0), ISR+FSR(1), ISR+INT+FSR(2)
-      read(7,*) fsrnlo    ! yes(1), no(0)
-      read(7,*) ivac      ! no(0),yes; by Fred Jegerlehner(1),yes;by Thomas Teubner(2)
-      read(7,*) FF_Pion   ! KS Pionformfactor(0), GS Pionformfactor(1) old, GS Pionformfactor new(2)
-      read(7,*) f0_model  ! f0+f0(600): KK model(0), no structure(1), no f0+f0(600)(2), f0 KLOE(3)
-      read(7,*) FF_kaon   ! KaonFormFactor constrained (0),KaonFormFactor unconstrained (1),KaonFormFactor old (2)
-      read(7,*) narr_res  ! no narrow resonances (0), J/Psi (1), Psi(2S) (2) (narro resonances only for pion = 0, 1, 6, 7
-      read(7,*) FF_pp     !ProtonFormFactor old(0), ProtonFormFactor new(1)
-      read(7,*) FF_Pgg
-      read(7,*) chi_sw         !Radiative return(0), Chi production(1), Radiative return + Chi production (2)
-      read(7,*) be_r            !be_r: without beam resolution(0), with beam resolution(1)
+!      read(7,*)           !                                   
+!      read(7,*) nges      ! number of generated events        
+!      read(7,*) nm        ! events to determine the maximum   
+!      read(7,*) outfile   ! output file                       
+!      read(7,*) iprint    ! printing(1), nonprinting(0) generated events
+!      read(7,*) ph0       ! Born: 1ph(0)radiative return; Born: 0ph(1) scan
+!      read(7,*) nlo       ! radiative return mode: Born(0), NLO(1)
+!      read(7,*) nlo2      ! full NLO: No(0), Yes(1)
+!      read(7,*) w         ! soft photon cutoff                
+!      read(7,*) pion      ! mu+mu-(0),pi+pi-(1),2pi0pi+pi-(2),2pi+2pi-(3),ppbar(4),nnbar(5),K+K-(6),K0K0bar(7),pi+pi-pi0(8), Lamb Lambbar->pi-pi+ppbar(9) 
+!      read(7,*) fsr       ! ISR only(0), ISR+FSR(1), ISR+INT+FSR(2)
+!      read(7,*) fsrnlo    ! yes(1), no(0)
+!      read(7,*) ivac      ! no(0),yes; by Fred Jegerlehner(1),yes;by Thomas Teubner(2)
+!      read(7,*) FF_Pion   ! KS Pionformfactor(0), GS Pionformfactor(1) old, GS Pionformfactor new(2)
+!      read(7,*) f0_model  ! f0+f0(600): KK model(0), no structure(1), no f0+f0(600)(2), f0 KLOE(3)
+!      read(7,*) FF_kaon   ! KaonFormFactor constrained (0),KaonFormFactor unconstrained (1),KaonFormFactor old (2)
+!      read(7,*) narr_res  ! no narrow resonances (0), J/Psi (1), Psi(2S) (2) (narro resonances only for pion = 0, 1, 6, 7
+!      read(7,*) FF_pp     !ProtonFormFactor old(0), ProtonFormFactor new(1)
+!      read(7,*) FF_Pgg
+!      read(7,*) chi_sw         !Radiative return(0), Chi production(1), Radiative return + Chi production (2)
+!      read(7,*) be_r            !be_r: without beam resolution(0), with beam resolution(1)
 c --- input collider parameters -------------------
-      read(7,*)           !                                   
-      read(7,*) E         ! CMS-energy 
-      read(7,*) beamres ! beam resolution                         
+!      read(7,*)           !                                   
+!      read(7,*) E         ! CMS-energy 
+!      read(7,*) beamres ! beam resolution                         
 c --- input experimental cuts ---------------------
-      read(7,*)           !                                   
-      read(7,*) q2min     ! minimal  hadrons(muons)-gamma-inv mass squared 
-      read(7,*) q2_min_c  ! minimal inv. mass squared of the hadrons(muons)
-      read(7,*) q2_max_c  ! maximal inv. mass squared of the hadrons(muons)
-      read(7,*) gmin      ! minimal photon energy/missing energy             
-      read(7,*) phot1cut  ! minimal photon angle/missing momentum angle
-      read(7,*) phot2cut  ! maximal photon angle/missing momentum angle
-      read(7,*) pi1cut    ! minimal hadrons(muons) angle
-      read(7,*) pi2cut    ! maximal hadrons(muons) angle
+!      read(7,*)           !                                   
+!      read(7,*) q2min     ! minimal  hadrons(muons)-gamma-inv mass squared 
+!      read(7,*) q2_min_c  ! minimal inv. mass squared of the hadrons(muons)
+!      read(7,*) q2_max_c  ! maximal inv. mass squared of the hadrons(muons)
+!      read(7,*) gmin      ! minimal photon energy/missing energy             
+!      read(7,*) phot1cut  ! minimal photon angle/missing momentum angle
+!      read(7,*) phot2cut  ! maximal photon angle/missing momentum angle
+!      read(7,*) pi1cut    ! minimal hadrons(muons) angle
+!      read(7,*) pi2cut    ! maximal hadrons(muons) angle
 c --- read histogram paremeters -------------------
-      read(7,*)           ! 
-      do i = 0,20         ! read title, limits and bins       
-         read(7,*) title(i)
-         read(7,*) xlow(i),xup(i),bins(i)
-      enddo
-      close(7)
+!      read(7,*)           ! 
+!      do i = 0,20         ! read title, limits and bins       
+!         read(7,*) title(i)
+!         read(7,*) xlow(i),xup(i),bins(i)
+!      enddo
+!      close(7)
 c
 c --- input couplings, masses and meson widths ---
       read(8,*)           !                                   
@@ -2250,8 +2420,8 @@ c --- fix constants -------------------------------
       mpi_q=mpi
       alpha = 1.d0/alpha
       alpha_q= alpha
-      Sp = E*E    
-      Sp_q= E*E                            ! CMS-energy squared
+      Sp = ecm*ecm    
+      Sp_q= ecm*ecm                           ! CMS-energy squared
       ebeam = dSqrt(Sp)/2.d0                  ! beam energy
       ebeam_q = Sqrt(Sp_q)/2.q0
       w_q=w
@@ -3288,6 +3458,7 @@ c
           gamchiee2=dconjg(gg2)*gg2/40.d0/pi*mchic2
           write(10,*)'Gamma(chi_c2-> e+ e-)=', gamchiee2      
          endif  
+      
 
        if((pion.eq.13).or.(pion.eq.14).or.(pion.eq.15))then
          if(FF_Pgg.eq.0)then
@@ -3419,7 +3590,11 @@ c
       cpp(2,2,2,2)=con3*Jeemin(2,2,2,2)
       endif
 c
-      return
+      ! ========================================================================
+      !  added by Kirill Chilikin, 2019
+      ! ========================================================================
+      close(8)
+      ! ========================================================================      return
       end
 c***********************************************************************
       subroutine init_ha
@@ -5433,6 +5608,7 @@ c --- Generates: pion costheta and phi angles in Lambda rest-frame
 c ------------------------------------------------------------------------
       subroutine pionanglesLamb(cosmin,cosmax,costhm,phim,
      1                          costhp,phip)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       real*8 jacobian,x1,x2,jac1,jac2,cosmin,cosmax,x
       real*8 costhm,phim,costhp,phip,rr1_ll(0:3)
@@ -5464,6 +5640,7 @@ c q3    - four momentum of pi^-    |   q2,q3 - four momenta of pi^-
 c q4    - four momentum of pi^+    |
 c ------------------------------------------------------------------
       subroutine pionangles_1(qq2,q0p,q2p,q0b,q2b,fac)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       integer ip0,i,ru
       real*8 Arp(8),Arp_r(0:7)
@@ -5596,6 +5773,7 @@ c q2    - four momentum of pi^-
 c q3    - four momentum of pi^0
 c
       subroutine pionangles_2(qq2,q0p,q2p,fac)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
 
       real*8 rr,rr_r(0:5),qq2,q1,q2,q3,fac,rlam,a,b,c,x1min,q0,x1max,
@@ -5743,6 +5921,7 @@ c q2    - four momentum of pi^+
 c q3    - four momentum of pi^-
 c
       subroutine pionangles_eta(qq2,q0p,q2p,fac)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
 
       real*8 rr,rr_r(0:5),qq2,q1,q2,q3,fac,rlam,a,b,c,x1min,q0,x1max,
@@ -5874,6 +6053,7 @@ c *******************************************************************
 c generation of the 3pi invariant mass: flat + omega Breit-Wigner
 c *******************************************************************
       subroutine chann1(rrr,q2p_min,q2p_max,q2p,dx1,ip0)
+      use belle2_phokhara_interface
       implicit none
       real*8 rrr,q2p_min,q2p_max,q2p,dx1,dm,dg,dm2,dmg,rr1(1),
      1       rr1_r(0:2),vol1,vol2,vol3,vol4,vol,r1_test,r2_test,r3_test,
@@ -6424,6 +6604,7 @@ c ========================================================================
 c --- Spin Lambda test
 c ------------------------------------------------------------------------
       subroutine test_spin(qq,Hadronic,amplit,accepted)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       real*8 Matrix,qq,amplit
       real*8 rr_ll,ff_min_ll,ff_max_ll,ff_ll,ff_spin_ll
@@ -6454,6 +6635,7 @@ c========================================================================
 c        Spin lambda test for 0 photon part
 c 
       subroutine test_spin0(qq,Hadronic,amplit,accepted)
+      use belle2_phokhara_interface
       include 'phokhara_10.0.inc'
       real*8 Matrix,qq,amplit
       real*8 rr_ll,ff_min_ll,ff_max_ll,ff_ll,ff_spin_ll
@@ -15267,6 +15449,7 @@ c************contribution from gamma gamma
 
 c----------beam resolution--------------------------------------------------------------------------------
        subroutine beam_res
+      use belle2_phokhara_interface
        include 'phokhara_10.0.inc'
        real*8 r1(0:1),r2,rr,phi,ebeam1,ebeam2,p1(4),p2(4),sm(4)
        real*8 dme,el_m2
diff --git a/random.cc b/random.cc
new file mode 100644
index 0000000..c09ba98
--- /dev/null
+++ b/random.cc
@@ -0,0 +1,9 @@
+
+#include "TRandom.h"
+
+extern "C" void phokhara_rndmarray(double* drvec, int* lengt)
+{
+  for (int i = 0; i < *lengt; ++i) {
+    drvec[i] = gRandom->Rndm();
+  }
+}
