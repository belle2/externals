diff --git a/source/geometry/solids/Boolean/src/G4SubtractionSolid.cc b/source/geometry/solids/Boolean/src/G4SubtractionSolid.cc
index fbc6a05..f1376e0 100644
--- a/source/geometry/solids/Boolean/src/G4SubtractionSolid.cc
+++ b/source/geometry/solids/Boolean/src/G4SubtractionSolid.cc
@@ -136,7 +136,7 @@ G4SubtractionSolid::operator = (const G4SubtractionSolid& rhs)
 
 ///////////////////////////////////////////////////////////////
 //
-// CalculateExtent
+// Calculate extent under transform and specified limit
      
 G4bool 
 G4SubtractionSolid::CalculateExtent( const EAxis pAxis,
@@ -146,7 +146,7 @@ G4SubtractionSolid::CalculateExtent( const EAxis pAxis,
                                            G4double& pMax ) const 
 {
   // Since we cannot be sure how much the second solid subtracts 
-  // from the first,    we must use the first solid's extent!
+  // from the first, we must use the first solid's extent!
 
   return fPtrSolidA->CalculateExtent( pAxis, pVoxelLimit, 
                                       pTransform, pMin, pMax );
@@ -169,12 +169,13 @@ EInside G4SubtractionSolid::Inside( const G4ThreeVector& p ) const
   }
   else
   {
+    static const G4double rtol
+      = 1000.0*G4GeometryTolerance::GetInstance()->GetRadialTolerance();
     if(( positionA == kInside && positionB == kSurface) ||
        ( positionB == kOutside && positionA == kSurface) ||
        ( positionA == kSurface && positionB == kSurface &&
          ( fPtrSolidA->SurfaceNormal(p) - 
-           fPtrSolidB->SurfaceNormal(p) ).mag2() > 
-         1000.0*G4GeometryTolerance::GetInstance()->GetRadialTolerance() ) )
+           fPtrSolidB->SurfaceNormal(p) ).mag2() > rtol ) )
     {
       return kSurface;
     }
@@ -193,8 +194,11 @@ G4ThreeVector
 G4SubtractionSolid::SurfaceNormal( const G4ThreeVector& p ) const 
 {
   G4ThreeVector normal;
-  EInside insideThis= Inside(p); 
-  if( insideThis == kOutside )
+
+  EInside InsideA = fPtrSolidA->Inside(p);
+  EInside InsideB = fPtrSolidB->Inside(p); 
+
+  if( InsideA == kOutside )
   {
 #ifdef G4BOOLDEBUG
     G4cout << "WARNING - Invalid call [1] in "
@@ -206,46 +210,41 @@ G4SubtractionSolid::SurfaceNormal( const G4ThreeVector& p ) const
            << "  Point p is outside !" << G4endl;
     G4cerr << "          p = " << p << G4endl;
 #endif
+    normal = fPtrSolidA->SurfaceNormal(p) ;
   }
-  else
-  { 
-    EInside InsideA = fPtrSolidA->Inside(p); 
-    EInside InsideB = fPtrSolidB->Inside(p); 
-
-    if( InsideA == kSurface && 
-        InsideB != kInside      ) 
+  else if( InsideA == kSurface && 
+           InsideB != kInside      ) 
+  {
+    normal = fPtrSolidA->SurfaceNormal(p) ;
+  }
+  else if( InsideA == kInside && 
+           InsideB != kOutside    )
+  {
+    normal = -fPtrSolidB->SurfaceNormal(p) ;
+  }
+  else 
+  {
+    if ( fPtrSolidA->DistanceToOut(p) <= fPtrSolidB->DistanceToIn(p) )
     {
       normal = fPtrSolidA->SurfaceNormal(p) ;
     }
-    else if( InsideA == kInside && 
-             InsideB != kOutside    )
+    else
     {
       normal = -fPtrSolidB->SurfaceNormal(p) ;
     }
-    else 
-    {
-      if ( fPtrSolidA->DistanceToOut(p) <= fPtrSolidB->DistanceToIn(p) )
-      {
-        normal = fPtrSolidA->SurfaceNormal(p) ;
-      }
-      else
-      {
-        normal = -fPtrSolidB->SurfaceNormal(p) ;
-      }
 #ifdef G4BOOLDEBUG
-      if(insideThis == kInside)
-      {
-        G4cout << "WARNING - Invalid call [2] in "
+    if(Inside(p) == kInside)
+    {
+      G4cout << "WARNING - Invalid call [2] in "
              << "G4SubtractionSolid::SurfaceNormal(p)" << G4endl
              << "  Point p is inside !" << G4endl;
-        G4cout << "          p = " << p << G4endl;
-        G4cerr << "WARNING - Invalid call [2] in "
+      G4cout << "          p = " << p << G4endl;
+      G4cerr << "WARNING - Invalid call [2] in "
              << "G4SubtractionSolid::SurfaceNormal(p)" << G4endl
              << "  Point p is inside !" << G4endl;
-        G4cerr << "          p = " << p << G4endl;
-      }
-#endif
+      G4cerr << "          p = " << p << G4endl;
     }
+#endif
   }
   return normal;
 }
@@ -258,7 +257,7 @@ G4double
 G4SubtractionSolid::DistanceToIn(  const G4ThreeVector& p,
                                    const G4ThreeVector& v  ) const 
 {
-  G4double dist = 0.0,disTmp = 0.0 ;
+  G4double dist = 0.0, dist2 = 0.0, disTmp = 0.0;
     
 #ifdef G4BOOLDEBUG
   if( Inside(p) == kInside )
@@ -284,7 +283,7 @@ G4SubtractionSolid::DistanceToIn(  const G4ThreeVector& p,
       if( fPtrSolidA->Inside(p+dist*v) != kInside )
       {
         G4int count1=0;
-        do
+        do   // Loop checking, 13.08.2015, G.Cosmo
         {
           disTmp = fPtrSolidA->DistanceToIn(p+dist*v,v) ;
 
@@ -296,8 +295,10 @@ G4SubtractionSolid::DistanceToIn(  const G4ThreeVector& p,
 
           if( Inside(p+dist*v) == kOutside )
           {
-            disTmp = fPtrSolidB->DistanceToOut(p+dist*v,v) ; 
-            dist += disTmp ;
+            disTmp = fPtrSolidB->DistanceToOut(p+dist*v,v) ;
+            dist2 = dist+disTmp;
+            if (dist == dist2)  { return dist; }   // no progress
+            dist = dist2 ;
             count1++;
             if( count1 > 1000 )  // Infinite loop detected
             {
@@ -351,7 +352,9 @@ G4SubtractionSolid::DistanceToIn(  const G4ThreeVector& p,
             {  
               return kInfinity ;
             }                 
-            dist += disTmp ;
+            dist2 = dist+disTmp;
+            if (dist == dist2)  { return dist; }   // no progress
+            dist = dist2 ;
             count2++;
             if( count2 > 1000 )  // Infinite loop detected
             {
@@ -377,7 +380,7 @@ G4SubtractionSolid::DistanceToIn(  const G4ThreeVector& p,
               return dist;
             }
           }
-        }
+        }    // Loop checking, 13.08.2015, G.Cosmo
       }
     }
   
