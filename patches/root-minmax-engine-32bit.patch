From 1bd13b8868a27fdec814c8c23951ed22c9d1cb65 Mon Sep 17 00:00:00 2001
From: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date: Wed, 13 Jan 2016 12:19:52 +0100
Subject: [PATCH 1/5] Update mixmax for 32 bits. Use the latest version from Konstantinos Savvidis, but change it for a magic number s=-1 (same value described in the paper) with decimation=2.
 Add also possibility to skip fist vector elements.

---
 math/mathcore/inc/Math/MixMaxEngine.h |    7 +-
 math/mathcore/src/MixMaxEngine.cxx    |    8 +-
 math/mathcore/src/mixmax.cxx          |  233 ++++++++++++++++++++-------------
 math/mathcore/src/mixmax.h            |  105 +++++++++++-----
 4 files changed, 232 insertions(+), 121 deletions(-)

diff --git a/math/mathcore/inc/Math/MixMaxEngine.h b/math/mathcore/inc/Math/MixMaxEngine.h
index 8d3d6b0..9b14e1d 100644
--- a/math/mathcore/inc/Math/MixMaxEngine.h
+++ b/math/mathcore/inc/Math/MixMaxEngine.h
@@ -82,7 +82,12 @@ namespace ROOT {
 
          /// set the number we want to use to skip generation
          /// higher value means higher luxury but slower
-         static void SetSkipNumber(int nskip); 
+         static void SetSkipNumber(int nskip);
+
+         /// set initial number to be used in the vector.
+         /// The previous elements are skipped and not returned.
+         static void SetFirstReturnElement(int index);
+
 
       private:
 
diff --git a/math/mathcore/src/MixMaxEngine.cxx b/math/mathcore/src/MixMaxEngine.cxx
index fb74edd..1bf8b65 100644
--- a/math/mathcore/src/MixMaxEngine.cxx
+++ b/math/mathcore/src/MixMaxEngine.cxx
@@ -36,11 +36,17 @@ namespace Math {
    //    seed_uniquestream(fRngState, clusterID,  machineID,  runID,   streamID);
    // }
 
-   // set decimation number
+   /// set decimation number
    void MixMaxEngine::SetSkipNumber(int nskip) {
       set_skip_number(nskip);
    }
    
+   /// set initial number to be used in the vector (the previous elements are skipped and not returned)
+   void MixMaxEngine::SetFirstReturnElement(int index)  {
+      set_first_return_element(index); 
+   }
+
+   
    void MixMaxEngine::SetSeed(unsigned int seed) { 
       seed_spbox(fRngState, seed);
       // no need to call iterate. The iteration will happen anyway
diff --git a/math/mathcore/src/mixmax.cxx b/math/mathcore/src/mixmax.cxx
index d4998a3..8733b90 100755
--- a/math/mathcore/src/mixmax.cxx
+++ b/math/mathcore/src/mixmax.cxx
@@ -1,16 +1,30 @@
-/*
- *  mixmax.c
- *  A Pseudo-Random Number Generator
- *
- *  Created by Konstantin Savvidy on Sun Feb 22 2004.
- *  As of version 0.99 and later, the code is being released under GNU Lesser General Public License v3
- *
- *	Generator described in 
- *	N.Z.Akopov, G.K.Savvidy and N.G.Ter-Arutyunian, Matrix Generator of Pseudorandom Numbers, 
- *	J.Comput.Phys. 97, 573 (1991); 
- *	Preprint EPI-867(18)-86, Yerevan Jun.1986;
- */
-
+// $Id:$
+// -*- C++ -*-
+//
+// -----------------------------------------------------------------------
+//            MixMax Matrix PseudoRandom Number Generator
+//                        --- MixMax ---
+//                       class header file
+// -----------------------------------------------------------------------
+//
+//
+//  Created by Konstantin Savvidy on Sun Feb 22 2004.
+//  As of version 0.99 and later, the code is being released under
+//  GNU Lesser General Public License v3
+//
+//	Generator described in 
+//	N.Z.Akopov, G.K.Savvidy and N.G.Ter-Arutyunian, Matrix Generator of Pseudorandom Numbers, 
+//	J.Comput.Phys. 97, 573 (1991); 
+//	Preprint EPI-867(18)-86, Yerevan Jun.1986;
+//
+//  and
+//
+//  K.Savvidy
+//  The MIXMAX random number generator
+//  Comp. Phys. Commun. (2015)
+//  http://dx.doi.org/10.1016/j.cpc.2015.06.003
+//
+// -----------------------------------------------------------------------
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -24,57 +38,82 @@
 
 int nskip = 2;  // number of iterations we want to skip (default is 2)
 
+int firstElement = 3; // first element we want to return of the vector and skipping the previous ones
+
 void set_skip_number(int n){
    nskip = n; 
 }
+void set_first_return_element(int n){
+   firstElement = n; 
+}
+
 int get_skip_number(){
    return nskip; 
 }
-
+int get_first_return_element(){
+   return firstElement; 
+}
 
 int iterate(rng_state_t* X){
    int niter = nskip+1; 
    for (int i = 0; i < niter; ++i) 
-      X->sumtot = iterate_raw_vec(X->V, X->sumtot);
+	X->sumtot = iterate_raw_vec(X->V, X->sumtot);
    return 0;
 }
 
+#if (SPECIALMUL!=0)
+inline uint64_t MULWU (uint64_t k){ return (( (k)<<(SPECIALMUL) & M61) | ( (k) >> (BITS-SPECIALMUL))  )  ;}
+#elif (SPECIALMUL==0)
+inline uint64_t MULWU (uint64_t k){ (void)k; return 0;}
+#else
+#error SPECIALMUL not undefined
+#endif
+
 myuint iterate_raw_vec(myuint* Y, myuint sumtotOld){
 	// operates with a raw vector, uses known sum of elements of Y
 	int i;
-	myuint  tempP, tempV;
-#if (SPECIAL != 0)
-	myuint temp2 = Y[1];
+#ifdef SPECIAL
+    myuint temp2 = Y[1];
 #endif
-	Y[0] = (tempV = modadd(Y[0] , sumtotOld));
-	__uint128_t sumtot = 0; // will keep a running sum of all new elements (except Y[0])
-	tempP = 0;              // will keep a partial sum of all old elements (except Y[0])
-	for (i=1; i<N; i++){
-        tempP = modadd(tempP,Y[i]);
-        Y[i] = ( tempV = modadd(tempV,tempP) );
-		sumtot += tempV;
-	}
-#if (SPECIAL != 0)
-	temp2 = MOD_MULSPEC(temp2);
-	Y[2] = modadd( Y[2] , temp2 );
-	sumtot += temp2;
+    myuint  tempP, tempV;
+    Y[0] = ( tempV = sumtotOld);
+    myuint sumtot = Y[0], ovflow = 0; // will keep a running sum of all new elements (except Y[0])
+    tempP = 0;              // will keep a partial sum of all old elements (except Y[0])
+    for (i=1; i<N; i++){
+#if (SPECIALMUL!=0)
+       myuint tempPO = MULWU(tempP);
+       tempP = modadd(tempP,Y[i]);
+       tempV = MOD_MERSENNE(tempV + tempP + tempPO); // edge cases ?
+#else
+       tempP = modadd(tempP , Y[i]);
+       tempV = modadd(tempV , tempP);
+#endif
+       Y[i] = tempV;
+       sumtot += tempV; if (sumtot < tempV) {ovflow++;}
+    }
+#ifdef SPECIAL
+    temp2 = MOD_MULSPEC(temp2);
+    Y[2] = modadd( Y[2] , temp2 );
+    sumtot += temp2; if (sumtot < temp2) {ovflow++;}
 #endif
-	return mod128(sumtot);
+    return MOD_MERSENNE(MOD_MERSENNE(sumtot) + (ovflow <<3 ));
 }
 
 myuint get_next(rng_state_t* X) {
     int i;
     i=X->counter;
+    
     if (i<(N) ){
         X->counter++;
         return X->V[i];
     }else{
        int niter = nskip + 1;
-        for (int iter = 0; iter < niter; ++iter) {
-           X->sumtot = iterate_raw_vec(X->V, X->sumtot);
-        }
-        X->counter=2;
-        return X->V[1]; 
+       for (int iter = 0; iter < niter; ++iter) {
+          X->sumtot = iterate_raw_vec(X->V, X->sumtot);
+       }
+
+       X->counter=firstElement+1;
+       return X->V[firstElement];
     }
 }
 
@@ -86,8 +125,8 @@ double get_next_float(rng_state_t* X){
     int64_t Z=(int64_t)get_next(X);
 #if defined(__SSE__) && defined(USE_INLINE_ASM)
     double F;
-    __asm__ ("pxor %0, %0;"
-             "cvtsi2sdq %1, %0;"
+    __asm__ ("pxor %0, %0; "
+             "cvtsi2sdq %1, %0; "
              :"=x"(F)
              :"r"(Z)
              );
@@ -98,15 +137,16 @@ double get_next_float(rng_state_t* X){
 
 }
 
+// LM: this should be fixed for skipping the first number (firstElement(
 void fill_array(rng_state_t* X, unsigned int n, double *array)
 {
     // Return an array of n random numbers uniformly distributed in (0,1]
     unsigned int i,j;
     const int M=N-1;
     for (i=0; i<(n/M); i++){
-        int niter = nskip+1;
-        for (int iter = 0; iter < niter; ++iter) 
-           iterate_and_fill_array(X, array+i*M);
+       int niter = nskip+1;
+       for (int iter = 0; iter < niter; ++iter) 
+          iterate_and_fill_array(X, array+i*M);
     }
     unsigned int rem=(n % M);
     if (rem) {
@@ -129,30 +169,29 @@ void iterate_and_fill_array(rng_state_t* X, double *array){
 #endif
     Y[0] = (tempV = modadd(Y[0] , X->sumtot));
     //array[0] = (double)tempV * (double)(INV_MERSBASE);
-    __uint128_t sumtot = 0; // will keep a running sum of all new elements (except Y[0])
+    myuint sumtot = 0, ovflow = 0; // will keep a running sum of all new elements (except Y[0])
     tempP = 0;             // will keep a partial sum of all old elements (except Y[0])
     for (i=1; i<N; i++){
         tempP = modadd(tempP,Y[i]);
         Y[i] = ( tempV = modadd(tempV,tempP) );
-        sumtot += tempV;
+        sumtot += tempV; if (sumtot < tempV) {ovflow++;}
         array[i-1] = (int64_t)tempV * (double)(INV_MERSBASE);
     }
 #if (SPECIAL != 0)
     temp2 = MOD_MULSPEC(temp2);
     Y[2] = modadd( Y[2] , temp2 );
-    array[2] = (int64_t)Y[2] * (double)(INV_MERSBASE);
-    sumtot += temp2;
+    sumtot += temp2; if (sumtot < temp2) {ovflow++;}
 #endif
-    X->sumtot = mod128(sumtot);
+    X->sumtot = MOD_MERSENNE(MOD_MERSENNE(sumtot) + (ovflow <<3 ));
 }
 
 myuint modadd(myuint foo, myuint bar){
 #if defined(__x86_64__) && defined(USE_INLINE_ASM)
     myuint out;
     /* Assembler trick suggested by Andrzej GoÌˆrlich     */
-    __asm__ ("addq %2, %0;"
-             "btr $61, %0;"
-             "adcq $0, %0;"
+    __asm__ ("addq %2, %0; "
+             "btrq $61, %0; "
+             "adcq $0, %0; "
              :"=r"(out)
              :"0"(foo), "r"(bar)
              );
@@ -184,17 +223,15 @@ rng_state_t*  rng_copy(myuint *Y)
 	 Partial sums on this new state are recalculated, and counter set to zero, so that when get_next is called, 
 	 it will output the initial vector before any new numbers are produced, call iterate(X) if you want to advance right away */
 	rng_state_t* X = rng_alloc();
-	__uint128_t sumtmp;
-
+    myuint sumtot=0,ovflow=0;
 	X->counter = 2;
-	sumtmp = 0;
-	X->V[0] = Y[0];
     int i;
-	for ( i=1; i < N; i++){
-		X->V[i] = Y[i]; 
-		sumtmp +=  X->V[(i)] ; 
+	for ( i=0; i < N; i++){
+		X->V[i] = Y[i];
+        sumtot += X->V[(i)]; if (sumtot < X->V[(i)]) {ovflow++;}
+
 	}
-	X->sumtot = mod128(sumtmp);
+	X->sumtot = MOD_MERSENNE(MOD_MERSENNE(sumtot) + (ovflow <<3 ));
 	return X;
 }
 
@@ -211,7 +248,7 @@ int i;
 	}
 	X->counter = N;  // set the counter to N if iteration should happen right away
 	//precalc(X);
-	X->sumtot = (index ? 1:0);
+    X->sumtot = 1; //(index ? 1:0);
 	if (X->fh==NULL){X->fh=stdout;}	
 }
 
@@ -219,31 +256,30 @@ void seed_spbox(rng_state_t* X, myuint seed)
 { // a 64-bit LCG from Knuth line 26, in combination with a bit swap is used to seed
 	const myuint MULT64=6364136223846793005ULL; 
 	int i;
-	__uint128_t sumtmp;
+    myuint sumtot=0,ovflow=0;
 	if (seed == 0){
 		fprintf(stderr, " try seeding with nonzero seed next time!\n");
 		exit(SEED_WAS_ZERO);
 	}
 	
 	myuint l = seed;
-	sumtmp = 0; 
 
-	X->V[0] = l & MERSBASE;
+	//X->V[0] = l & MERSBASE;
 	if (X->fh==NULL){X->fh=stdout;} // if the filehandle is not yet set, make it stdout
-	for (i=1; i < N; i++){
+	for (i=0; i < N; i++){
 		l*=MULT64; l = (l << 32) ^ (l>>32);
 		X->V[i] = l & MERSBASE;
-		sumtmp += (X->V[i]);
+        sumtot += X->V[(i)]; if (sumtot < X->V[(i)]) {ovflow++;}
 	}
 	X->counter = N;  // set the counter to N if iteration should happen right away
-	X->sumtot= mod128(sumtmp);
+    X->sumtot = MOD_MERSENNE(MOD_MERSENNE(sumtot) + (ovflow <<3 ));
 }
 
 myuint precalc(rng_state_t* X){
 	int i;
 	myuint temp;
 	temp = 0;
-	for (i=1; i < N; i++){
+	for (i=0; i < N; i++){
 		temp = MOD_MERSENNE(temp + X->V[i]);
 	}	
 	X->sumtot = temp; 
@@ -253,27 +289,46 @@ myuint precalc(rng_state_t* X){
 
 int rng_get_N(void){return N;}
 
-#define MASK32 0xFFFFFFFFULL
+//#define MASK32 0xFFFFFFFFULL
+
+
+//inline myuint modmulM61(myuint a, myuint b){
+//	// my best modmul so far
+//	__uint128_t temp;
+//	temp = (__uint128_t)a*(__uint128_t)b;
+//	return mod128(temp);
+//}
 
+#if defined(__x86_64__)
 inline myuint mod128(__uint128_t s){
-	myuint s1;
-	s1 = ( (  ((myuint)s)&MERSBASE )    + (  ((myuint)(s>>64)) * 8 )  + ( ((myuint)s) >>BITS) );
-	return	MOD_MERSENNE(s1);
+    myuint s1;
+    s1 = ( (  ((myuint)s)&MERSBASE )    + (  ((myuint)(s>>64)) * 8 )  + ( ((myuint)s) >>BITS) );
+    return	MOD_MERSENNE(s1);
 }
 
-inline myuint modmulM61(myuint a, myuint b){
-	// my best modmul so far
+inline myuint fmodmulM61(myuint cum, myuint a, myuint b){
 	__uint128_t temp;
-	temp = (__uint128_t)a*(__uint128_t)b;
+	temp = (__uint128_t)a*(__uint128_t)b + cum;
 	return mod128(temp);
 }
 
+#else // on all other platforms, including 32-bit linux, PPC and PPC64 and all Windows
+#define MASK32 0xFFFFFFFFULL
 
-inline myuint fmodmulM61(myuint cum, myuint a, myuint b){
-	__uint128_t temp;
-	temp = (__uint128_t)a*(__uint128_t)b + cum;
-	return mod128(temp);
+inline myuint fmodmulM61(myuint cum, myuint s, myuint a)
+{
+    register myuint o,ph,pl,ah,al;
+    o=(s)*a;
+    ph = ((s)>>32);
+    pl = (s) & MASK32;
+    ah = a>>32;
+    al = a & MASK32;
+    o = (o & M61) + ((ph*ah)<<3) + ((ah*pl+al*ph + ((al*pl)>>32))>>29) ;
+    o += cum;
+    o = (o & M61) + ((o>>61));
+    return o;
 }
+#endif
 
 void print_state(rng_state_t* X){
     int j;
@@ -339,7 +394,7 @@ void read_state(rng_state_t* X, const char filename[] ){
         fprintf(stderr, "mixmax -> checksum error while reading state from file %s - corrupted?\n", filename);
         exit(ERROR_READING_STATE_CHECKSUM);
     }
-    else{fprintf(stderr, "mixmax -> read_state: checksum ok: %llu == %llu\n",X->sumtot,  sumtot);}
+//    else{fprintf(stderr, "mixmax -> read_state: checksum ok: %llu == %llu\n",X->sumtot,  sumtot);}
     fclose(fin);
 }
 
@@ -388,14 +443,13 @@ myuint apply_bigskip(myuint* Vout, myuint* Vin, myID_t clusterID, myID_t machine
 	const	myuint skipMat[128][N] = 
 	
 #if (N==88) 
-#include "mixmax_skip_N88.c"  // to make this file, delete all except some chosen 128 rows of the coefficients table
+#include "mixmax_skip_N88.icc"  // to make this file, delete all except some chosen 128 rows of the coefficients table
 #elif (N==256) 
 #include "mixmax_skip_N256.icc"
-//#include "mixmax_skip_N256.dev.c"
 #elif (N==1000) 
-#include "mixmax_skip_N1000.c"
+#include "mixmax_skip_N1000.icc"
 #elif (N==3150) 
-#include "mixmax_skip_N3150.c"
+#include "mixmax_skip_N3150.icc"
 #endif
 	;
 	
@@ -405,9 +459,10 @@ myuint apply_bigskip(myuint* Vout, myuint* Vin, myID_t clusterID, myID_t machine
 	myuint Y[N], cum[N];
 	myuint coeff;
 	myuint* rowPtr;
-	__uint128_t sumtot = 0;
+    myuint sumtot=0;
 	
-	for (i=0; i<N; i++) { Y[i] = Vin[i]; sumtot += Vin[i]; } ; sumtot -= Vin[0]; sumtot = mod128(sumtot) ;
+
+    for (i=0; i<N; i++) { Y[i] = Vin[i]; sumtot = modadd( sumtot, Vin[i]); } ;
 	for (IDindex=0; IDindex<4; IDindex++) { // go from lower order to higher order ID
 		id=IDvec[IDindex];
 		//printf("now doing ID at level %d, with ID = %d\n", IDindex, id);     
@@ -423,15 +478,15 @@ myuint apply_bigskip(myuint* Vout, myuint* Vin, myID_t clusterID, myID_t machine
 					FUSEDMODMULVEC;
 					sumtot = iterate_raw_vec(Y, sumtot); 
 				}
-				sumtot=0;
-				for (i=0; i<N; i++){ Y[i] = cum[i]; sumtot += cum[i]; } sumtot -= Y[0]; sumtot = mod128(sumtot) ;	
+                sumtot=0;
+                for (i=0; i<N; i++){ Y[i] = cum[i]; sumtot = modadd( sumtot, cum[i]); } ;
 			}
 		id = (id >> 1); r++; // bring up the r-th bit in the ID		
 		}		
 	}
-	sumtot=0;
-	for (i=0; i<N; i++){ Vout[i] = Y[i]; sumtot += Y[i]; } ; sumtot -= Y[0]; // returns sumtot, and copy the vector over to Vout 
-	return mod128(sumtot) ;
+    sumtot=0;
+	for (i=0; i<N; i++){ Vout[i] = Y[i]; sumtot = modadd( sumtot, Y[i]); } ;  // returns sumtot, and copy the vector over to Vout
+	return (sumtot) ;
 }
 #else
 #warning For this N, we dont have the skipping coefficients yet, using alternative method to seed
@@ -452,3 +507,5 @@ void seed_uniquestream( rng_state_t* Xin, myID_t clusterID, myID_t machineID, my
 #endif // SKIPISON
 
 
+
+
diff --git a/math/mathcore/src/mixmax.h b/math/mathcore/src/mixmax.h
index efa6f98..0a4437a 100755
--- a/math/mathcore/src/mixmax.h
+++ b/math/mathcore/src/mixmax.h
@@ -1,11 +1,39 @@
+// $Id:$
+// -*- C++ -*-
+//
+// -----------------------------------------------------------------------
+//            MixMax Matrix PseudoRandom Number Generator
+//                        --- MixMax ---
+//                       class header file
+// -----------------------------------------------------------------------
+//
+//
+//  Created by Konstantin Savvidy on Sun Feb 22 2004.
+//  The code is released under
+//  GNU Lesser General Public License v3
+//
+//	Generator described in 
+//	N.Z.Akopov, G.K.Savvidy and N.G.Ter-Arutyunian, Matrix Generator of Pseudorandom Numbers, 
+//	J.Comput.Phys. 97, 573 (1991); 
+//	Preprint EPI-867(18)-86, Yerevan Jun.1986;
+//
+//  and
+//
+//  K.Savvidy
+//  The MIXMAX random number generator
+//  Comp. Phys. Commun. (2015)
+//  http://dx.doi.org/10.1016/j.cpc.2015.06.003
+//
+// -----------------------------------------------------------------------
+
+#ifndef ROOT_MIXMAX_H_
+#define ROOT_MIXMAX_H_ 1
+
+//#define USE_INLINE_ASM //DP: uncomment if want to use inline asm
+
 #include <stdio.h>
 #include <stdint.h>
 
-#ifndef MIXMAX_H_
-#define MIXMAX_H_
-
-//#define USE_INLINE_ASM //LM: uncomment if want to use inline asm
-
 
 #ifdef __cplusplus
 extern "C" {
@@ -28,7 +56,6 @@ typedef unsigned long long int myuint;
 //#warning but no problem,  'myuint' is 'unsigned long long int'
 #endif
 
-
 struct rng_state_st
 {
     myuint V[N];
@@ -43,15 +70,19 @@ int  rng_get_N(void); // get the N programmatically, useful for checking the val
 
 rng_state_t  *rng_alloc();                 /* allocate the state */
 int           rng_free(rng_state_t* X);    /* free memory occupied by the state */
-rng_state_t  *rng_copy(myuint *Y);         /* init from vector, takes the vector Y, returns pointer to the newly allocated and initialized state */
+rng_state_t  *rng_copy(myuint *Y);         /* init from vector, takes the vector Y, 
+                                               returns pointer to the newly allocated and initialized state */
 void read_state(rng_state_t* X, const char filename[] );
 void print_state(rng_state_t* X);
-    int iterate(rng_state_t* X);
-    myuint iterate_raw_vec(myuint* Y, myuint sumtotOld);
+int iterate(rng_state_t* X);
+myuint iterate_raw_vec(myuint* Y, myuint sumtotOld);
 
 void set_skip_number(int n);
+void set_first_return_element(int n);
 int get_skip_number();
+int get_first_return_element();
    
+
 //   FUNCTIONS FOR SEEDING
 
 typedef uint32_t myID_t;
@@ -91,11 +122,10 @@ void branch_inplace( rng_state_t* Xin, myID_t* ID ); // almost the same as apply
 #define BITS  61
 
 /* magic with Mersenne Numbers */
-    
+
 #define M61   2305843009213693951ULL
 
     myuint modadd(myuint foo, myuint bar);
-    myuint mod128(__uint128_t s);
     myuint modmulM61(myuint s, myuint a);
     myuint fmodmulM61(myuint cum, myuint s, myuint a);
 
@@ -110,27 +140,37 @@ void branch_inplace( rng_state_t* Xin, myID_t* ID ); // almost the same as apply
 // the charpoly is irreducible for the combinations of N and SPECIAL and has maximal period for N=508, 256, half period for 1260, and 1/12 period for 3150
 
 #if (N==256)
-#define SPECIAL -1
-#define MOD_MULSPEC(k) (MERSBASE-(k))
+#define SPECIALMUL 0
+#define SPECIAL -1  // 487013230256099064ULL // s=487013230256099064, m=1 -- good old MIXMAX
+#define MOD_MULSPEC(k) fmodmulM61( 0, SPECIAL , (k) );
+    
+#elif (N==17)
+#define SPECIALMUL 36 // m=2^37+1
+
+#elif (N==8)
+#define SPECIALMUL 53 // m=2^53+1
 
-#elif (N==3150)
-#define SPECIAL -11
-#define MOD_MULSPEC(k) (( ( ( 6*(MERSBASE-(k) )) % MERSBASE) + ( ( 5*(MERSBASE-(k) )) % MERSBASE) ) % MERSBASE )
+#elif (N==40)
+#define SPECIALMUL 42 // m=2^42+1
 
-#elif (N==1000 || N==1051 || N==44)
-#define SPECIAL 0
-#define MOD_MULSPEC(k) (0)
+#elif (N==96)
+#define SPECIALMUL 55 // m=2^55+1
 
-#elif (N==88 || N==40)
+#elif (N==64)
+#define SPECIALMUL 55 // m=2^55 (!!!) and m=2^37+2
+    
+#elif (N==120)
+#define SPECIALMUL 51   // m=2^51+1 and a SPECIAL=+1 (!!!)
 #define SPECIAL 1
-#define MOD_MULSPEC(k) (k)
+#define MOD_MULSPEC(k) (k);
 
 #else
-#define SPECIAL -1
-#define MOD_MULSPEC(k)  (MERSBASE-(k) )
-
+#warning Not a verified N, you are on your own!
+#define SPECIALMUL 58
+    
 #endif // list of interesting N for modulus M61 ends here
 
+
 #ifndef __MIXMAX_C // c++ can put code into header files, why cant we? (with the inline declaration, should be safe from duplicate-symbol error)
 	
 #define get_next(X) GET_BY_MACRO(X)
@@ -138,18 +178,18 @@ void branch_inplace( rng_state_t* Xin, myID_t* ID ); // almost the same as apply
 inline 	myuint GET_BY_MACRO(rng_state_t* X) {
     int i;
     i=X->counter;
-//        printf("get next i = %d \n",i); 
-
+    
     if (i<=(N-1) ){
         X->counter++;
         return X->V[i];
     }else{
        int niter = get_skip_number();
        for (int iter = 0; iter < niter; ++iter) {
-           X->sumtot = iterate_raw_vec(X->V, X->sumtot);
+          X->sumtot = iterate_raw_vec(X->V, X->sumtot);
        }
-        X->counter=2;
-        return X->V[1];
+       int element = get_first_return_element();
+       X->counter= element+1;
+       return X->V[element];
     }
 }
     
@@ -159,7 +199,7 @@ inline 	myuint GET_BY_MACRO(rng_state_t* X) {
 inline double get_next_float_BY_MACRO(rng_state_t* X){
         int64_t Z=(int64_t)get_next(X);
 #if defined(__SSE__) && defined(USE_INLINE_ASM)
-#warning using SSE inline assemly for int64 -> double conversion, not really necessary in GCC-5 or better
+//#warning using SSE inline assembly for int64 -> double conversion, not really necessary in GCC-5 or better
     double F;
         __asm__ ("pxor %0, %0;"
                  "cvtsi2sdq %1, %0;"
@@ -225,4 +265,7 @@ const gsl_rng_type *gsl_rng_ran3 = &mixmax_type;
 
 #endif // HOOKUP_GSL
 
-#endif // closing MIXMAX_H_
+
+#endif // closing ROOT_MIXMAX_H_
+//}  // namespace CLHEP
+
-- 
1.7.1


From 708a69a531683d27f1abd3cea8b9426cab407ff9 Mon Sep 17 00:00:00 2001
From: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date: Wed, 13 Jan 2016 12:22:52 +0100
Subject: [PATCH 2/5] Add test for new random number interface and MixMax

---
 math/mathcore/test/CMakeLists.txt     |    1 +
 math/mathcore/test/testMathRandom.cxx |  195 +++++++++++++++++++++++++++++++++
 2 files changed, 196 insertions(+), 0 deletions(-)
 create mode 100644 math/mathcore/test/testMathRandom.cxx

diff --git a/math/mathcore/test/CMakeLists.txt b/math/mathcore/test/CMakeLists.txt
index 30c1b97..3192351 100644
--- a/math/mathcore/test/CMakeLists.txt
+++ b/math/mathcore/test/CMakeLists.txt
@@ -7,6 +7,7 @@ set(Libraries Core RIO Net Hist Graf Graf3d Gpad Tree
               Rint Postscript Matrix Physics MathCore Thread)
 
 set(TestSource
+    testMathRandom.cxx
     testTMath.cxx
     testBinarySearch.cxx
     testSortOrder.cxx
diff --git a/math/mathcore/test/testMathRandom.cxx b/math/mathcore/test/testMathRandom.cxx
new file mode 100644
index 0000000..c248640
--- /dev/null
+++ b/math/mathcore/test/testMathRandom.cxx
@@ -0,0 +1,195 @@
+#include "Math/Random.h"
+#include "Math/TRandomEngine.h"
+#include "Math/MersenneTwisterEngine.h"
+#include "Math/MixMaxEngine.h"
+//#include "Math/MyMixMaxEngine.h"
+//#include "Math/GSLRndmEngines.h"
+#include "Math/GoFTest.h"
+#include "Math/ProbFunc.h"
+#include "TH1.h"
+#include "TCanvas.h"
+
+#include "TRandom1.h"
+#include "TRandom2.h"
+#include "TRandom3.h"
+//#include "TRandomNew3.h"
+
+#include "TStopwatch.h"
+#include <iostream>
+
+#include <random>
+
+using namespace ROOT::Math;
+
+const long long  NR = 1E7;
+double minPValue = 1.E-3;
+
+bool showPlots = false; 
+
+
+bool testCompatibility(const std::vector<double> & x, const std::vector<double> & y, double xmin = 0, double xmax = 1) {
+
+   GoFTest gof(x.size(), x.data(), y.size(), y.data() );
+
+   bool ok = true; 
+   double pvalue = gof.KolmogorovSmirnov2SamplesTest();
+   if ( pvalue < minPValue ) {
+      std::cout << "KS Test failed with p-value " << pvalue << std::endl;
+      ok = false; 
+   }
+   else  {
+      std::cout << "KS Test  :  OK - pvalue = " << pvalue << std::endl; 
+   }
+
+
+   if (NR < 10000) { 
+      pvalue = gof.AndersonDarling2SamplesTest(); 
+      if ( pvalue < minPValue ) {
+         std::cout << "AD Test failed with p-value " << pvalue << std::endl;
+         ok = false; 
+      }
+      else {
+         std::cout << "AD Test  :  OK - pvalue = " << pvalue << std::endl; 
+      }
+   } 
+
+   // do a chi2 binned test
+   int nbin = TMath::Min(x.size(), y.size() )/1000; 
+   TH1D * h1 = new TH1D("h1","h1", nbin, xmin, xmax);
+   TH1D * h2 = new TH1D("h2","h2", nbin, xmin, xmax);
+   h1->FillN(x.size(), x.data(), nullptr ); 
+   h2->FillN(y.size(), y.data(), nullptr );
+
+   pvalue = h1->Chi2Test(h2);
+   if ( pvalue < minPValue ) {
+      std::cout << "Chi2 Test failed with p-value " << pvalue << std::endl;
+      //showPlots = true; 
+      ok = false; 
+   }
+   else { 
+      std::cout << "Chi2 Test:  OK - pvalue = " << pvalue << std::endl; 
+   }
+   if (showPlots) {
+      h1->Draw();
+      h2->SetLineColor(kRed);
+      h2->Draw("SAME");
+      if (gPad) gPad->Update(); 
+   }
+   else {
+      delete h1;
+      delete h2; 
+   }
+
+   
+   return ok; 
+}
+
+template <class R1, class R2> 
+bool testUniform(R1 & r1, R2 & r2) {
+
+   
+   std::vector<double> x(NR);
+   std::vector<double> y(NR);
+
+   TStopwatch w; w.Start(); 
+   for (int i = 0; i < NR; ++i) 
+      x[i] = r1();
+
+   w.Stop();
+   std::cout << "time for uniform filled for " << typeid(r1).name();
+   w.Print(); 
+
+   w.Start(); 
+   for (int i = 0; i < NR; ++i) 
+      y[i] = r2();
+
+   w.Stop();
+   std::cout << "time for uniform filled for " << typeid(r2).name();
+   w.Print(); 
+
+   return testCompatibility(x,y);
+}
+
+template <class R1, class R2> 
+bool testGauss(R1 & r1, R2 & r2) {
+
+   
+   std::vector<double> x(NR);
+   std::vector<double> y(NR);
+
+   TStopwatch w; w.Start(); 
+   for (int i = 0; i < NR; ++i) 
+      x[i] = ROOT::Math::normal_cdf(r1.Gaus(0,1),1);
+
+   w.Stop();
+   std::cout << "time for GAUS filled for " << typeid(r1).name();
+   w.Print(); 
+
+   w.Start(); 
+   for (int i = 0; i < NR; ++i) 
+      y[i] = ROOT::Math::normal_cdf(r2.Gaus(0,1),1);
+
+   w.Stop();
+   std::cout << "time for GAUS filled for " << typeid(r2).name();
+   w.Print(); 
+
+   return testCompatibility(x,y);
+}
+
+bool test1() {
+
+   bool ret = true; 
+   std::cout << "\nTesting MT vs MIXMAX " << std::endl;
+
+   Random<MersenneTwisterEngine> rmt;
+   Random<MixMaxEngine> rmx;
+   ret &= testUniform(rmx, rmt);
+   ret &= testGauss(rmx, rmt);
+   return ret; 
+}
+
+bool test2() {
+
+   bool ret = true; 
+
+   std::cout << "\nTesting MIXMAX vs MIXMAX" << std::endl;
+
+   // this test fails if first elemet is 0 is present !
+   
+   Random<MixMaxEngine> rmx1(1111);
+   Random<MixMaxEngine> rmx2(2222);
+
+   ret &= testUniform(rmx1, rmx2);
+   ret &= testGauss(rmx1, rmx2);
+   return ret; 
+}
+
+
+bool testMathRandom() {
+
+   // mixmax decimation
+   // test fails without decimation
+#ifdef USE_MIXMAX_DECIMATION   
+   std::cout << "Info:: Remove MIXMAX decimation " << std::endl;
+   MixMaxEngine::SetSkipNumber(0);
+   MixMaxEngine::SetFirstReturnElement(1);
+#endif   
+
+   
+   bool ret = true;
+   std::cout << "testing generating " << NR << " numbers " << std::endl;
+
+   ret &= test1(); 
+   ret &= test2(); 
+
+   if (!ret) Error("testMathRandom","Test Failed");
+   else
+      std::cout << "\nTestMathRandom:  OK \n";
+   return ret; 
+}
+
+int main() {
+   bool ret = testMathRandom();
+   return (ret) ? 0 : -1;
+}
+      
-- 
1.7.1


From 775ec41bbb061afa05c162a9efa372e581cd6d39 Mon Sep 17 00:00:00 2001
From: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date: Thu, 14 Jan 2016 10:50:14 +0100
Subject: [PATCH 3/5] Extend MixMaxEngine class with some extra functions (Setting and getting the state vector, querying the size, etc..)

---
 math/mathcore/inc/Math/MixMaxEngine.h |   23 +++++++++++++++++++++++
 math/mathcore/src/MixMaxEngine.cxx    |   28 ++++++++++++++++++++++++++++
 2 files changed, 51 insertions(+), 0 deletions(-)

diff --git a/math/mathcore/inc/Math/MixMaxEngine.h b/math/mathcore/inc/Math/MixMaxEngine.h
index 9b14e1d..6c390cc 100644
--- a/math/mathcore/inc/Math/MixMaxEngine.h
+++ b/math/mathcore/inc/Math/MixMaxEngine.h
@@ -14,6 +14,7 @@
 #define ROOT_Math_MixMaxEngine
 
 #include <cstdint>
+#include <vector>
 
 #ifndef ROOT_Math_TRandomEngine
 #include "Math/TRandomEngine.h"
@@ -62,12 +63,34 @@ namespace ROOT {
 
          virtual ~MixMaxEngine();
 
+         /// get the state of the generator
+         void GetState(std::vector<uint64_t> & state) const;
+
+         /// Get the counter (between 0 and Size-1)
+         int Counter() const;
+
+         /// Get the size of the generator
+         static int Size();
+
+         /// maximum integer that can be generated. For MIXMAX is 2^61-1         
+         static uint64_t MaxInt() { return  0x1fffffffffffffff; } //  2^61 -1 
+
          /// set the generator seed 
          void  SetSeed(unsigned int seed);
 
          /// set the generator seed using a 64 bits integer
          void SetSeed64(uint64_t seed);
 
+         ///set the full initial generator state and warm up generator by doing some iterations
+         void SetState(const std::vector<uint64_t> & state, bool warmup = true);
+
+         /// set the counter
+         void SetCounter(int val);
+
+         // /// set the special number 
+         // static void SetSpecialNumber(uint64_t val); 
+
+
          // generate a random number (virtual interface)
          virtual double Rndm() { return Rndm_impl(); }
 
diff --git a/math/mathcore/src/MixMaxEngine.cxx b/math/mathcore/src/MixMaxEngine.cxx
index 1bf8b65..9acc40f 100644
--- a/math/mathcore/src/MixMaxEngine.cxx
+++ b/math/mathcore/src/MixMaxEngine.cxx
@@ -77,6 +77,34 @@ namespace Math {
       fill_array(fRngState, n,  array);
    }
 
+   void MixMaxEngine::SetState(const std::vector<uint64_t> & state, bool warmup) {
+      if (fRngState) rng_free(fRngState);
+      fRngState = rng_copy(const_cast<uint64_t*>(state.data()) );
+      if (warmup) iterate(fRngState); 
+   }
+
+   void MixMaxEngine::GetState(std::vector<uint64_t> & state) const {
+      int n =  rng_get_N(); 
+      state.resize(n);
+      for (int i = 0; i < n; ++i)
+         state[i] = fRngState->V[i];
+   }
+
+   int MixMaxEngine::Size()  {
+      return rng_get_N(); 
+   }
+
+   int MixMaxEngine::Counter() const {
+      return fRngState->counter; 
+   }
+
+   void MixMaxEngine::SetCounter(int val) {
+      fRngState->counter = val; 
+   }
+
+   // void MixMaxEngine::SetSpecialNumber(uint64_t /* val */ ) {
+   //    //set_special_number(val); 
+   // }
 
 
    
-- 
1.7.1


From 204706e14e7f6a8fa9ad43c9098da1f8970dc5e1 Mon Sep 17 00:00:00 2001
From: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date: Thu, 14 Jan 2016 14:26:44 +0100
Subject: [PATCH 4/5] Fix skipping in inline method

---
 math/mathcore/src/mixmax.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/math/mathcore/src/mixmax.h b/math/mathcore/src/mixmax.h
index 0a4437a..16decf1 100755
--- a/math/mathcore/src/mixmax.h
+++ b/math/mathcore/src/mixmax.h
@@ -183,7 +183,7 @@ inline 	myuint GET_BY_MACRO(rng_state_t* X) {
         X->counter++;
         return X->V[i];
     }else{
-       int niter = get_skip_number();
+       int niter = get_skip_number() +1;
        for (int iter = 0; iter < niter; ++iter) {
           X->sumtot = iterate_raw_vec(X->V, X->sumtot);
        }
-- 
1.7.1


From e3c415c406cd2c4e2f56cb89d6e288e387610f5d Mon Sep 17 00:00:00 2001
From: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date: Thu, 14 Jan 2016 18:38:36 +0100
Subject: [PATCH 5/5] Import from master fixes for compilation and warnings

---
 math/mathcore/inc/Math/MixMaxEngine.h |   13 +++++++++----
 math/mathcore/src/MixMaxEngine.cxx    |    6 +++---
 2 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/math/mathcore/inc/Math/MixMaxEngine.h b/math/mathcore/inc/Math/MixMaxEngine.h
index 6c390cc..944b286 100644
--- a/math/mathcore/inc/Math/MixMaxEngine.h
+++ b/math/mathcore/inc/Math/MixMaxEngine.h
@@ -57,14 +57,19 @@ namespace ROOT {
 
       public:
 
-         typedef  TRandomEngine BaseType; 
+         typedef  TRandomEngine BaseType;
+
+         // this should be changed for WINDOWS
+         typedef unsigned long long int StateInt_t;
+
+         
          
          MixMaxEngine(uint64_t seed=1);
 
          virtual ~MixMaxEngine();
 
          /// get the state of the generator
-         void GetState(std::vector<uint64_t> & state) const;
+         void GetState(std::vector<StateInt_t> & state) const;
 
          /// Get the counter (between 0 and Size-1)
          int Counter() const;
@@ -82,14 +87,14 @@ namespace ROOT {
          void SetSeed64(uint64_t seed);
 
          ///set the full initial generator state and warm up generator by doing some iterations
-         void SetState(const std::vector<uint64_t> & state, bool warmup = true);
+         void SetState(const std::vector<StateInt_t> & state, bool warmup = true);
 
          /// set the counter
          void SetCounter(int val);
 
          // /// set the special number 
-         // static void SetSpecialNumber(uint64_t val); 
 
+         // static void SetSpecialNumber(uint64_t val); 
 
          // generate a random number (virtual interface)
          virtual double Rndm() { return Rndm_impl(); }
diff --git a/math/mathcore/src/MixMaxEngine.cxx b/math/mathcore/src/MixMaxEngine.cxx
index 9acc40f..0c3059d 100644
--- a/math/mathcore/src/MixMaxEngine.cxx
+++ b/math/mathcore/src/MixMaxEngine.cxx
@@ -77,13 +77,13 @@ namespace Math {
       fill_array(fRngState, n,  array);
    }
 
-   void MixMaxEngine::SetState(const std::vector<uint64_t> & state, bool warmup) {
+   void MixMaxEngine::SetState(const std::vector<StateInt_t> & state, bool warmup) {
       if (fRngState) rng_free(fRngState);
-      fRngState = rng_copy(const_cast<uint64_t*>(state.data()) );
+      fRngState = rng_copy(const_cast<StateInt_t*>(state.data()) );
       if (warmup) iterate(fRngState); 
    }
 
-   void MixMaxEngine::GetState(std::vector<uint64_t> & state) const {
+   void MixMaxEngine::GetState(std::vector<StateInt_t> & state) const {
       int n =  rng_get_N(); 
       state.resize(n);
       for (int i = 0; i < n; ++i)
-- 
1.7.1

