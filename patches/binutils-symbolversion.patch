From 73ab4b30f4fbb522d7c42d20a61f9d3b708f7342 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Thu, 9 Aug 2018 08:09:46 -0700
Subject: [PATCH] Always clear h->verinfo.verdef when overriding a dynamic
 definition

When linker defines a symbol to override a dynamic definition, it should
always clear h->verinfo.verdef so that the symbol won't be associated
with the version information from the dynamic object.  This happened to
the symbol "_edata" when creating an unversioned dynamic object linking
against:

1. libKF5ConfigCore.so.5.49.0
2. libKF5CoreAddons.so.5.49.0
3. libKF5I18n.so.5.49.0
4. libKF5DBusAddons.so.5.49.0
5. libQt5Xml.so.5.11.1
6. libQt5DBus.so.5.11.1
7. libQt5Core.so.5.11.1

Among them

libQt5Xml.so.5.11.1
   299: 000000000003e000     0 NOTYPE  GLOBAL DEFAULT   18 _edata@@Qt_5
libQt5DBus.so.5.11.1
   597: 0000000000092018     0 NOTYPE  GLOBAL DEFAULT   18 _edata@@Qt_5
libQt5Core.so.5.11.1
  2292: 00000000004df640     0 NOTYPE  GLOBAL DEFAULT   21 _edata@Qt_5
  2293: 00000000004df640     0 NOTYPE  GLOBAL DEFAULT   21 _edata@Qt_5

The problem is triggered by 2 duplicated entries of _edata@Qt_5 in
libQt5Core.so.5.11.1 which was created by gold.  Before this commit,
ld created the dynamic object with "_edata" in its dynamic symbol table
which was linker defined and associated with the version information
from libQt5Core.so.5.11.1.  The code in question was there when the
binutils source was imported to sourceware.org.  When such a dynamic
object was used later, we got:

/usr/bin/ld: bin/libKF5Service.so.5.49.0: _edata: invalid version 21 (max 0)
/usr/bin/ld: bin/libKF5Service.so.5.49.0: error adding symbols: bad value

Tested with many ELF targets.

	PR ld/23499
	* elflink.c (bfd_elf_record_link_assignment): Always clear
	h->verinfo.verdef when overriding a dynamic definition.
---
 bfd/elflink.c | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/bfd/elflink.c b/bfd/elflink.c
index b24fb95848..02618bed8f 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -686,13 +686,11 @@ bfd_elf_record_link_assignment (bfd *output_bfd,
       && !h->def_regular)
     h->root.type = bfd_link_hash_undefined;
 
-  /* If this symbol is not being provided by the linker script, and it is
-     currently defined by a dynamic object, but not by a regular object,
-     then clear out any version information because the symbol will not be
-     associated with the dynamic object any more.  */
-  if (!provide
-      && h->def_dynamic
-      && !h->def_regular)
+  /* If this symbol is currently defined by a dynamic object, but not
+     by a regular object, then clear out any version information because
+     the symbol will not be associated with the dynamic object any
+     more.  */
+  if (h->def_dynamic && !h->def_regular)
     h->verinfo.verdef = NULL;
 
   /* Make sure this symbol is not garbage collected.  */

From 7a815dd566f3dd32435ac73aa0a0cc948d525e06 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Sat, 25 Aug 2018 06:17:52 -0700
Subject: [PATCH] elf: Check for corrupt symbol version info

The BFD linker with PR ld/23499 may generate shared libraries with
corrupt symbol version info which leads to linker error when the
corrupt shared library is used:

/usr/bin/ld: bin/libKF5Service.so.5.49.0: _edata: invalid version 21 (max 0)
/usr/bin/ld: bin/libKF5Service.so.5.49.0: error adding symbols: bad value

Add check for corrupt symbol version info to objdump:

00000000000af005 g    D  .data	0000000000000000  <corrupt>   _edata

and readelf:

   728: 00000000000af005     0 NOTYPE  GLOBAL DEFAULT   25 _edata@<corrupt> (5)

bfd/

	PR ld/23499
	* elf.c (_bfd_elf_get_symbol_version_string): Return
	_("<corrupt>") for corrupt symbol version info.

binutils/

	PR ld/23499
	* readelf.c (get_symbol_version_string): Return _("<corrupt>")
	for corrupt symbol version info.
---
 bfd/elf.c          | 2 +-
 binutils/readelf.c | 9 +++++++++
 4 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/bfd/elf.c b/bfd/elf.c
index efdaf2e..b8860c4 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -1877,7 +1877,7 @@ _bfd_elf_get_symbol_version_string (bfd *abfd, asymbol *symbol,
 	{
 	  Elf_Internal_Verneed *t;
 
-	  version_string = "";
+	  version_string = _("<corrupt>");
 	  for (t = elf_tdata (abfd)->verref;
 	       t != NULL;
 	       t = t->vn_nextref)
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 8d4054f..23e61d3 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -11300,6 +11300,7 @@ get_symbol_version_string (Filedata *                   filedata,
   unsigned char data[2];
   unsigned short vers_data;
   unsigned long offset;
+  unsigned short max_vd_ndx;
 
   if (!is_dynsym
       || version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0)
@@ -11317,6 +11318,8 @@ get_symbol_version_string (Filedata *                   filedata,
   if ((vers_data & VERSYM_HIDDEN) == 0 && vers_data == 0)
     return NULL;
 
+  max_vd_ndx = 0;
+
   /* Usually we'd only see verdef for defined symbols, and verneed for
      undefined symbols.  However, symbols defined by the linker in
      .dynbss for variables copied from a shared library in order to
@@ -11359,6 +11362,9 @@ get_symbol_version_string (Filedata *                   filedata,
 	      ivd.vd_flags = BYTE_GET (evd.vd_flags);
 	    }
 
+	  if ((ivd.vd_ndx & VERSYM_VERSION) > max_vd_ndx)
+	    max_vd_ndx = ivd.vd_ndx & VERSYM_VERSION;
+
 	  off += ivd.vd_next;
 	}
       while (ivd.vd_ndx != (vers_data & VERSYM_VERSION) && ivd.vd_next != 0);
@@ -11450,6 +11456,9 @@ get_symbol_version_string (Filedata *                   filedata,
 	  return (ivna.vna_name < strtab_size
 		  ? strtab + ivna.vna_name : _("<corrupt>"));
 	}
+      else if ((max_vd_ndx || (vers_data & VERSYM_VERSION) != 1)
+	       && (vers_data & VERSYM_VERSION) > max_vd_ndx)
+	return _("<corrupt>");
     }
   return NULL;
 }
-- 
2.9.3

